/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
"use strict";
/**
 * It caches the result of the factory so multiple calls return the same object.
 *
 * @return another function. When the returned function is called first time, it calls
 *         the factory, caches the result of the factory call and return it. Next time,
 *         it returns the cached value and doesn't call the factory any more.
 */
function lazy(factory) {
    var value = undefined;
    return function () {
        if (value === undefined) {
            value = factory();
        }
        return value;
    };
}
exports.lazy = lazy;
/**
 * The function is asynchronous analougue of 'finally'.
 *
 * Execute finalize() after the value promise is resolved or rejected.
 *
 * The function will not affect the state of the returned Promise. It will be still resolved or rejected
 * the same way as the original value. However, if an error occurs in the finalize() then the
 * returned Promise will be rejected.
 *
 * @return a new promise instance that will be once again resolved or rejected after executing the finalize function.
 */
function promiseFinally(value, finalize) {
    var finalizeAndContinue = function (result) { return Promise.resolve(finalize()).then(function () { return result; }); };
    return value.then(finalizeAndContinue, function (e) { return finalizeAndContinue(Promise.reject(e)); });
}
exports.promiseFinally = promiseFinally;
// calls f and returns promisified result. If f throws an exeption,
// the function returns a rejected promise.
function _call(f) {
    return Promise.resolve().then(f);
}
function _deferredDisposable(init) {
    return {
        using: function (context) { return init()
            .then(function (disposable) { return promiseFinally(_call(function () { return context(disposable.value); }), disposable.dispose); }); },
        init: init,
        map: function (f) { return _deferredDisposable(function () { return init().then(function (disposable) { return ({
            value: f(disposable.value),
            dispose: disposable.dispose,
        }); }); }); },
        and: function (f) { return _deferredDisposable(function () { return init()
            .then(function (disposable1) { return _call(function () { return f(disposable1.value).init(); })
            .then(function (disposable2) { return ({
            value: disposable2.value,
            dispose: function () {
                // disposable1.dispose must be called in any case.
                return promiseFinally(disposable2.dispose(), disposable1.dispose);
            },
        }); }, function (err) {
            // disposable1.dispose must be called.
            disposable1.dispose();
            return Promise.reject(err);
        }); }); }); },
    };
}
/**
 * An implementation of DeferredDisposable.
 */
function deferredDisposable(init, dispose) {
    var initDisposable = function () { return _call(init).then(function (value) { return ({
        value: value,
        dispose: lazy(function () { return _call(function () { return dispose(value); }); }),
    }); }); };
    return _deferredDisposable(initDisposable);
}
exports.deferredDisposable = deferredDisposable;
