"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var child_process_1 = require('child_process');
var q = require('q');
var path = require('path');
var ec = require('errno-codes');
var discoveryServiceProxy_1 = require('./discoveryServiceProxy');
var jsonRpc_1 = require('./jsonRpc');
var findFile_1 = require('./findFile');
var relativePath_1 = require('./relativePath');
var serviceDiscovery_1 = require('./serviceDiscovery');
var hostInfo_1 = require('./hostInfo');
var exitCode_1 = require('./exitCode');
var serviceDescriptor_1 = require('./serviceDescriptor');
var common_1 = require('./common');
var randomHexString_1 = require('./randomHexString');
var logger_1 = require('./logger');
var libraryResourceStrings_1 = require('./libraryResourceStrings');
var controllerEngineToken = '$CONTROLLERENGINE';
/** Debug host on startup environment variable. Must be in sync with EnvUtils.DebugHostOnStartupEnvVarName in src\clr\utility\Microsoft.ServiceHub.Utility.Shared\EnvUtils.cs */
var DebugHostOnStartupEnvVarName = 'SERVICEHUBDEBUGHOSTONSTARTUP';
var HostIdentity = (function () {
    function HostIdentity(host) {
        if (!host) {
            throw new Error(libraryResourceStrings_1.LibraryResourceStrings.variableIsNotDefined('host'));
        }
        if (!host.host) {
            throw new Error(libraryResourceStrings_1.LibraryResourceStrings.variableIsNotDefined('host.host'));
        }
        this.hostId = host.hostId;
        this.host = host.host;
        this.hostGroup = host.hostGroup;
    }
    HostIdentity.prototype.getId = function () {
        return this.host + (this.hostId ? '$' + this.hostId : '') + (this.hostGroup ? '$$' + this.hostGroup : '');
    };
    HostIdentity.prototype.getHostInfoFileGlobPattern = function () {
        // Glob allows searching for multiple files if {option1,option2} set notation is used.
        return this.hostId ? "{" + this.host + "." + this.hostId + "," + this.host + "}" : this.host;
    };
    HostIdentity.create = function (smi, serviceDescriptor) {
        var hostGroup = serviceDescriptor && serviceDescriptor.hasHostGroup() ? serviceDescriptor.hostGroup.id : null;
        return new HostIdentity({ hostId: smi.hostId, host: smi.host, hostGroup: hostGroup });
    };
    return HostIdentity;
}());
exports.HostIdentity = HostIdentity;
var HostInfo = (function (_super) {
    __extends(HostInfo, _super);
    function HostInfo(host, hostProcess) {
        _super.call(this, host);
        this.hostProcess = hostProcess;
        this.endPoint = q.defer();
        this.services = [];
        this.hasActiveServices = false;
        this.pendingStartServiceRequestCount = 0;
        this.touch();
    }
    HostInfo.prototype.setCooldownTimeout = function (callback, ms) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        this.clearCooldownTimeout();
        this.cooldownTimeout = global.setTimeout.apply(global, [callback, ms].concat(args));
    };
    HostInfo.prototype.clearCooldownTimeout = function () {
        if (this.cooldownTimeout) {
            global.clearTimeout(this.cooldownTimeout);
            this.cooldownTimeout = null;
        }
    };
    HostInfo.prototype.touch = function () {
        this.lastAccessTimeMs = new Date().getTime();
    };
    return HostInfo;
}(HostIdentity));
var LocationService = (function () {
    function LocationService(logger, config, options) {
        this.hosts = {};
        this.hostPids = [];
        this.locatedServices = {};
        this.hostInfoMap = {};
        this.externalClientCount = 0;
        if (!logger) {
            throw new common_1.ServiceHubError(common_1.ErrorKind.InvalidArgument, libraryResourceStrings_1.LibraryResourceStrings.variableIsNotDefined('logger'));
        }
        if (!config) {
            throw new common_1.ServiceHubError(common_1.ErrorKind.InvalidArgument, libraryResourceStrings_1.LibraryResourceStrings.variableIsNotDefined('config'));
        }
        options = options || {};
        this.hostCooldownMs = options.hostCooldownMs || 10 * 1000;
        this.fastShutdownHostCooldownMs = options.fastShutdownHostCooldownMs || 500;
        this.logger = logger;
        this.config = config;
        this.callbackPipeName = randomHexString_1.default().then(function (value) { return common_1.formatPipeName(value); });
        this.sessionId = randomHexString_1.default();
    }
    LocationService.prototype.locate = function (serviceDescriptor, clientInfo) {
        var _this = this;
        var service = new serviceDescriptor_1.ServiceDescriptor(serviceDescriptor);
        clientInfo = clientInfo || {};
        var clientId = "" + (clientInfo.clientName || 'client') + (clientInfo.pid ? " (pid: " + clientInfo.pid + ")" : '');
        var serviceKey = service.getServiceKey();
        this.logger.info(libraryResourceStrings_1.LibraryResourceStrings.locatingService(serviceKey, clientId));
        if (this.isExternalClient(clientInfo)) {
            this.stopFastShutdown();
        }
        return this.getHostedServiceLocation(service)
            .then(function (serviceLocation) {
            if (serviceLocation.host.shutdown) {
                // The host is shutting down; We need to locate the service again.
                return _this.locate(serviceDescriptor, clientInfo);
            }
            // Increase the host lifetime, to allow the client connect to the service,
            // and the host get back to us notifying about the started service.
            serviceLocation.host.touch();
            // Update the cached service location.
            // We don't cache IServiceLocation.clientWatch because it depends on whether the client is external or not.
            _this.locatedServices[serviceKey] = q.resolve(serviceLocation);
            var locationAndHost = serviceLocation.location + " @ " + serviceLocation.host.getId();
            _this.logger.info(libraryResourceStrings_1.LibraryResourceStrings.serviceLocated(serviceLocation.serviceId, locationAndHost, clientId));
            // Check if we want to watch for the client lifetime.
            return q.resolve(_this.isExternalClient(clientInfo) ? _this.getClientWatchServerName() : null)
                .then(function (clientWatch) { return { location: serviceLocation.location, serviceId: serviceLocation.serviceId, clientWatch: clientWatch }; });
        })
            .catch(function (reason) {
            _this.logger.error(libraryResourceStrings_1.LibraryResourceStrings.startingServiceFailed(serviceKey, clientId, "" + (reason.message || reason)));
            return q.reject(reason);
        });
    };
    LocationService.prototype.stop = function () {
        var _this = this;
        var hosts = common_1.getPropertiesArray(this.hosts).map(function (hostPromise) { return hostPromise.then(function (host) { return _this.stopHost(host, libraryResourceStrings_1.LibraryResourceStrings.forceControllerShutDown); }); });
        return q.all(hosts);
    };
    /**
    * Gets session ID
    *
    * Session ID is a unique string that stays the same during dev hub session (life time of hub controller)
    * and is different for different sessions.
    */
    LocationService.prototype.getSessionId = function () {
        return this.sessionId;
    };
    LocationService.prototype.getServiceModuleInfo = function (service) {
        var _this = this;
        var serviceDiscoveryConfig = {
            servicesFolderPath: this.config.services.rootDir,
            discoveryHelper: function (s) { return _this.discoverService(s); },
        };
        return serviceDiscovery_1.getServiceModuleInfo(this.logger, service, serviceDiscoveryConfig);
    };
    LocationService.prototype.discoverService = function (service, discoveryServices, discoveryServiceIndex) {
        var _this = this;
        if (!discoveryServices) {
            discoveryServices = this.config.services.discoveryServices;
            if (!discoveryServices || discoveryServices.length == 0 || discoveryServices.indexOf(service) >= 0) {
                return q.resolve(null);
            }
            return this.discoverService(service, discoveryServices, 0 /* discoveryServiceIndex */);
        }
        if (discoveryServices.length <= discoveryServiceIndex) {
            // We tried all known discovery services and couldn't find the service.
            return q.resolve(null);
        }
        var discoveryServiceName = discoveryServices[discoveryServiceIndex];
        var proxy = new discoveryServiceProxy_1.default(this.logger, this, discoveryServiceName);
        return proxy.discoverService(service)
            .then(function (filePath) { return filePath ? { filePath: filePath } : null; }, function (error) {
            _this.logger.error(libraryResourceStrings_1.LibraryResourceStrings.locatingServcieError(discoveryServiceName, service, error.message, error.stack));
            return { error: new Error(discoveryServiceName + ": " + error.message) };
        })
            .finally(function () {
            proxy.end()
                .catch(function (err) { return _this.logger.error(libraryResourceStrings_1.LibraryResourceStrings.disconnectingDiscoveryServiceFailed(discoveryServiceName, err.message, err.stack)); })
                .done();
        })
            .then(function (result) { return result || _this.discoverService(service, discoveryServices, discoveryServiceIndex + 1); });
    };
    /**
     * Find hub host info for the given host type by locating and parsing <host>.servicehub.host.json
     */
    LocationService.prototype.getHubHostInfo = function (hostIdentity) {
        var _this = this;
        if (!hostIdentity || !hostIdentity.host) {
            throw new common_1.ServiceHubError(common_1.ErrorKind.InvalidArgument, libraryResourceStrings_1.LibraryResourceStrings.variableIsNotDefined(!hostIdentity ? 'hostIdentity' : 'hostIdentity.host'));
        }
        var hostId = hostIdentity.getId();
        if (this.hostInfoMap.hasOwnProperty(hostId)) {
            return this.hostInfoMap[hostId];
        }
        var globPattern = hostIdentity.getHostInfoFileGlobPattern();
        return this.hostInfoMap[hostId] = this.findHostConfigFile(globPattern)
            .then(function (filePath) {
            _this.logger.info(libraryResourceStrings_1.LibraryResourceStrings.loadingHostInfo(hostId, filePath));
            return common_1.parseFileAsJson(filePath)
                .then(function (result) {
                LocationService.verifyHostInfo(result, filePath);
                result.filePath = filePath;
                result.hostExecutable = result.hostExecutable.replace(controllerEngineToken, function () { return process.execPath; });
                return relativePath_1.expandDotRelativePaths(result, path.dirname(filePath), ['host', 'hostExecutable']);
            })
                .catch(function (err) {
                throw new common_1.ServiceHubError(common_1.ErrorKind.HubHostInfoLoadError, libraryResourceStrings_1.LibraryResourceStrings.cannotResolveHost(hostId, filePath, err.message));
            });
        });
    };
    LocationService.prototype.findHostConfigFile = function (fileNameGlobPattern) {
        var filePattern = '*/' + fileNameGlobPattern + '.servicehub.host.json';
        var localHostDir = path.join(__dirname, common_1.Constants.HostInfoFolderName);
        var configHostDir = this.config.hosts ? this.config.hosts.rootDir : null;
        var hubHostFile = configHostDir ? findFile_1.default(filePattern, { cwd: configHostDir, nodir: true, fileSelector: fileSelector, nosort: true }) : q.resolve(null);
        return hubHostFile
            .then(function (filePath) { return filePath || findFile_1.default(filePattern, { cwd: localHostDir, nodir: true, fileSelector: fileSelector, nosort: true }); })
            .then(function (filePath) {
            if (filePath) {
                return filePath;
            }
            var message = configHostDir ?
                libraryResourceStrings_1.LibraryResourceStrings.hostTypeNotFoundInLocation(fileNameGlobPattern, configHostDir, localHostDir) :
                libraryResourceStrings_1.LibraryResourceStrings.hostTypeNotFound(fileNameGlobPattern, localHostDir);
            throw new common_1.ServiceHubError(common_1.ErrorKind.HubHostInfoLoadError, message);
        });
        // There may be multiple config files found by the glob pattern.
        // The first one is the most specific, always pick it.
        function fileSelector(files) {
            return files[0];
        }
    };
    /**
     * A host must report that it has at least one active client
     * by invoking this method on the host callback pipe.
     */
    LocationService.prototype.hostServicesStarted = function (hostId) {
        if (!hostId) {
            throw new Error(libraryResourceStrings_1.LibraryResourceStrings.variableIsNotDefined('hostId'));
        }
        if (this.hosts.hasOwnProperty(hostId)) {
            this.hosts[hostId].then(function (h) { return h.hasActiveServices = true; });
        }
    };
    /**
     * A host must report that it has no more active clients
     * by invoking this method on the host callback pipe.
     */
    LocationService.prototype.hostServicesEnded = function (hostId) {
        var _this = this;
        if (!hostId) {
            throw new Error(libraryResourceStrings_1.LibraryResourceStrings.variableIsNotDefined('hostId'));
        }
        if (this.hosts.hasOwnProperty(hostId)) {
            this.hosts[hostId].then(function (host) { return _this.startHostCooldown(host); });
        }
    };
    /** A new host has connected to the location service */
    LocationService.prototype.onHostConnected = function () { };
    /** Last host has disconnected from the location service */
    LocationService.prototype.onLastHostDisconnected = function () { };
    ;
    /**
     * Verify hub host info.
     *
     * This method checks if the hub host info has mandatory fields but does not have reserved fields.
     * It throws if these conditions are not met.
     */
    LocationService.verifyHostInfo = function (hostInfo, path) {
        if (!hostInfo) {
            throw new common_1.ServiceHubError(common_1.ErrorKind.InvalidArgument, libraryResourceStrings_1.LibraryResourceStrings.hostInfoNotDefined(path));
        }
        if (!hostInfo.hostExecutable || typeof hostInfo.hostExecutable !== 'string'
            || !hostInfo.hostArgs || typeof hostInfo.hostArgs !== 'object' || !Array.isArray(hostInfo.hostArgs)) {
            throw new common_1.ServiceHubError(common_1.ErrorKind.InvalidArgument, libraryResourceStrings_1.LibraryResourceStrings.hostInfoInvalid(path));
        }
        if (hostInfo.filePath) {
            var message = libraryResourceStrings_1.LibraryResourceStrings.hostInfoContainsReservedProperty(path);
            throw new common_1.ServiceHubError(common_1.ErrorKind.InvalidArgument, message);
        }
    };
    LocationService.isHostDebuggingOnStartupRequested = function () {
        return process.env[DebugHostOnStartupEnvVarName] ? true : false;
    };
    LocationService.isHostDebuggingOnStartupRequestedForHost = function (hostInfo) {
        var debugServiceHostOnStartupEnvVar = process.env[DebugHostOnStartupEnvVarName];
        if (!debugServiceHostOnStartupEnvVar) {
            return false;
        }
        debugServiceHostOnStartupEnvVar = debugServiceHostOnStartupEnvVar.toLowerCase();
        if (debugServiceHostOnStartupEnvVar === 'all' || debugServiceHostOnStartupEnvVar === path.basename(hostInfo.hostExecutable).toLowerCase()) {
            return true;
        }
        return false;
    };
    /**
     * Start service module process if it is not running yet.
     * @param: service - service module name, resolvable to a .json or .js file that either conforms to c.IServiceModuleInfo
     *                   or provides 'serviceModule' export that conforms to c.IServiceModuleInfo.
     */
    LocationService.prototype.getHostedServiceLocation = function (service) {
        var _this = this;
        var serviceKey = service.getServiceKey();
        // If somebody else has asked for the service before, use that promise
        if (this.locatedServices.hasOwnProperty(serviceKey)) {
            return this.locatedServices[serviceKey];
        }
        return this.getServiceModuleInfo(service.name).then(function (smi) {
            // If somebody else has already started the service, use it instead.
            if (_this.locatedServices.hasOwnProperty(serviceKey)) {
                return _this.locatedServices[serviceKey];
            }
            var result = _this.startService(smi, service);
            // Save the service promise so the next calls for the same service name can use that service.
            _this.locatedServices[serviceKey] = result;
            return result;
        });
    };
    LocationService.prototype.startService = function (smi, serviceDescriptor) {
        var _this = this;
        if (serviceDescriptor.hasHostGroup() && !smi.hostGroupAllowed) {
            var message = libraryResourceStrings_1.LibraryResourceStrings.HostGroupNotSupported(serviceDescriptor.name, serviceDescriptor.hostGroup.id, 'hostGroupAllowed');
            throw new common_1.ServiceHubError(common_1.ErrorKind.HostGroupsNotSupported, message);
        }
        var serviceKey = serviceDescriptor.getServiceKey();
        this.logger.info(libraryResourceStrings_1.LibraryResourceStrings.firstTimeLoadingService(serviceKey));
        var hostIdentity = HostIdentity.create(smi, serviceDescriptor);
        var hostId = hostIdentity.getId();
        var hostPromise;
        if (this.hosts.hasOwnProperty(hostId)) {
            hostPromise = this.hosts[hostId];
        }
        else {
            hostPromise = this.hosts[hostId] = this.startNewHost(hostIdentity);
        }
        // Sign up our continuation that we will run after the host has launched and is ready for a service request. The given channel is used to communicate
        // our launch request with the host.
        return hostPromise.then(function (host) {
            if (host.shutdown) {
                _this.logger.info("The host '" + host.getId() + "' for service '" + serviceDescriptor.name + "' is shutting down. We'll start a new host then.");
                return _this.startService(smi, serviceDescriptor);
            }
            // Track serivce running by the host.
            host.services.push(serviceKey);
            // Starting a new service may take some time.
            // Increase the pending request count to prevent the host from shutting down while the new service is starting.
            host.pendingStartServiceRequestCount++;
            return host.endPoint.promise
                .then(function (endPoint) { return endPoint.sendRequest(hostInfo_1.HostMethod.StartService, [smi]); })
                .then(function (location) {
                // Delay host shutdown after it started a new service to allow the client to connect to it.
                host.touch();
                return { location: location, host: host, serviceId: serviceDescriptor.name };
            })
                .finally(function () { return host.pendingStartServiceRequestCount--; });
        });
    };
    LocationService.prototype.startNewHost = function (hostIdentity) {
        var _this = this;
        var hostId = hostIdentity.getId();
        var hostCallbackPipeName = null;
        return this.getHostCallbackPipe()
            .then(function (pipeName) {
            hostCallbackPipeName = pipeName;
            return _this.getHubHostInfo(hostIdentity);
        })
            .then(function (hostInfo) {
            var hostDir = path.dirname(hostInfo.filePath);
            var debugHostOnStartup = LocationService.isHostDebuggingOnStartupRequestedForHost(hostInfo);
            // if NodeDebugArgs exists in the host args then if debugging is requested replace it with '--inspect-brk --nolazy' otherwise remove it
            var nodeDebugArgsIndex = hostInfo.hostArgs.indexOf(hostInfo_1.HostArgsToken.NodeDebugArgs);
            if (nodeDebugArgsIndex >= 0) {
                if (debugHostOnStartup) {
                    hostInfo.hostArgs.splice(nodeDebugArgsIndex, 1, '--inspect-brk', '--nolazy');
                }
                else {
                    hostInfo.hostArgs.splice(nodeDebugArgsIndex, 1);
                }
            }
            var args = []
                .concat(hostInfo.hostArgs.map(function (arg) { return arg
                .replace(hostInfo_1.HostArgsToken.HostId, function () { return hostId; })
                .replace(hostInfo_1.HostArgsToken.Pipe, function () { return hostCallbackPipeName; }); }));
            _this.logger.info(libraryResourceStrings_1.LibraryResourceStrings.launchingHostWithCmd(hostId, hostInfo.hostExecutable + " " + args.map(function (arg) { return ("\"" + arg + "\""); }).join(' ')));
            var process = child_process_1.spawn(hostInfo.hostExecutable, args, { cwd: hostDir });
            logger_1.traceProcessOutput(_this.logger, process, "HubHost '" + hostId + "'");
            var result = new HostInfo(hostIdentity, process);
            process.once('exit', function (code, signal) { return _this.onHostExit(result, code, signal); });
            process.once('error', function (err) { return _this.onHostError(result, err); });
            if (!debugHostOnStartup) {
                // When the host just starts, it doesn't have any service on it yet.
                // Even though the hub controller will immediately ask it to start a service,
                // the client may still not connect to the service for a long time, so we'll shut down
                // the host due to inactivity.
                _this.startHostCooldown(result);
            }
            else {
                // startHostCooldown ensures that when a host is started but no client connects to it within 10s
                // then the host will be shutdown. We disable that behavior when user has requested host debugging.
                _this.logger.info("Skipping startHostCooldown since debugging on startup has been requested for host " + hostInfo.hostExecutable);
            }
            _this.logger.info(libraryResourceStrings_1.LibraryResourceStrings.hostLaunched(hostId, result.hostProcess.pid.toString()));
            return result;
        });
    };
    LocationService.prototype.onHostExit = function (host, code, signal) {
        var withCode = code !== undefined && code !== null ? libraryResourceStrings_1.LibraryResourceStrings.hostExitedWithCode(code, exitCode_1.default[code] ? " (" + exitCode_1.default[code] + ")" : '') : '';
        var withSignal = signal !== undefined && signal !== null ? libraryResourceStrings_1.LibraryResourceStrings.hostExitedWithSignal(signal) : '';
        var message = libraryResourceStrings_1.LibraryResourceStrings.hostExited(host.host, host.hostProcess.pid.toString()) + withCode + withSignal;
        // Remove the host pid
        var pidIndex = this.hostPids.indexOf(host.hostProcess.pid);
        if (pidIndex >= 0) {
            this.hostPids.splice(pidIndex, 1);
        }
        this.forgetHost(host, new common_1.ServiceHubError(common_1.ErrorKind.InvalidOperation, message));
    };
    LocationService.prototype.onHostError = function (host, error) {
        this.forgetHost(host, error);
    };
    LocationService.prototype.forgetHost = function (host, rejectHostEndpointReason) {
        if (!host.shutdown) {
            if (rejectHostEndpointReason) {
                host.endPoint.reject(rejectHostEndpointReason);
            }
            host.shutdown = true;
            delete this.hosts[host.getId()];
            for (var _i = 0, _a = host.services; _i < _a.length; _i++) {
                var serviceKey = _a[_i];
                delete this.locatedServices[serviceKey];
            }
            if (Object.getOwnPropertyNames(this.hosts).length === 0) {
                this.onLastHostDisconnected();
            }
        }
    };
    LocationService.prototype.onHostConnecting = function (endPoint, id) {
        // The host has gotten back to us on the host callback pipe we passed as a command line arg. This means we now have a duplex
        // connection with the host that we can use to send startService requests. Since we only launch hosts in response to a service request from a
        // client, this callback means we have a pending launch, we need to complete our promise so the launch code can then communicate the service launch
        // request over the given endpoint to the host.
        var _this = this;
        if (this.hosts.hasOwnProperty(id)) {
            this.hosts[id].done(function (host) {
                // Save the host PID.
                _this.hostPids.push(host.hostProcess.pid);
                // Stash away the endpoint in the host info.
                host.endPoint.resolve(endPoint);
                // If the host end point ends, consider the host gone.
                // Another case when the host is gone is when its process exits.
                endPoint.onClose(function () { return _this.forgetHost(host); }, _this);
                _this.onHostConnected();
            });
        }
        else {
            this.logger.error(libraryResourceStrings_1.LibraryResourceStrings.hostInfoNotFound(id));
        }
    };
    LocationService.prototype.onGetHostIdFailed = function (error) {
        this.logger.error(libraryResourceStrings_1.LibraryResourceStrings.getHostIdFailed("" + (error.message || error)));
        // See if we have only one pending host and reject it if so.
        var singleHostEndpoint = null;
        for (var id in this.hosts) {
            if (!this.hosts.hasOwnProperty(id)) {
                continue;
            }
            var state = this.hosts[id].inspect();
            if (state.state !== 'fulfilled') {
                continue;
            }
            var endPoint = state.value.endPoint;
            if (endPoint.promise.isPending) {
                if (singleHostEndpoint !== null) {
                    // If there is more than one host pending, we do not know which one failed, so just log an error.
                    this.logger.error(libraryResourceStrings_1.LibraryResourceStrings.moreThanOneHostPending);
                    return;
                }
                singleHostEndpoint = endPoint;
            }
        }
        if (singleHostEndpoint !== null) {
            singleHostEndpoint.reject(error);
        }
    };
    LocationService.prototype.getHostCallbackPipe = function () {
        var _this = this;
        return this.callbackPipeName
            .then(function (pipeName) {
            if (_this.callbackPipeCreated) {
                return pipeName;
            }
            var options = {
                name: 'hostCallback',
                logger: _this.logger,
                pipeName: pipeName
            };
            return common_1.serverManager.startService(options, function (stream) {
                var endPoint = jsonRpc_1.JsonRpcConnection.attach(stream, _this.logger, _this, [
                    'hostServicesStarted',
                    'hostServicesEnded'
                ]);
                q(endPoint.sendRequest('getHostId'))
                    .then(function (id) { return _this.onHostConnecting(endPoint, id); })
                    .catch(function (error) { return _this.onGetHostIdFailed(error); })
                    .done();
            })
                .then(function () {
                _this.callbackPipeCreated = true;
                return pipeName;
            });
        });
    };
    LocationService.prototype.getClientWatchServerName = function () {
        var _this = this;
        if (!this.clientWatchServerName) {
            var serverOptions = {
                name: 'clientWatch',
                logger: this.logger,
                onErrorCb: function (e) {
                    var message = "Error in Client Watch server: " + e.message;
                    _this.logger.error(message);
                },
            };
            this.clientWatchServerName = common_1.serverManager.startService(serverOptions, this.onClientWatchConnection.bind(this));
        }
        return this.clientWatchServerName;
    };
    LocationService.prototype.onClientWatchConnection = function (stream) {
        var _this = this;
        this.logger.info('External client connected to client watch.');
        this.externalClientCount++;
        this.stopFastShutdown();
        stream.once('end', function () {
            _this.logger.info('External client disconnected from client watch.');
            _this.externalClientCount--;
            if (_this.externalClientCount === 0) {
                _this.startFastShutdown();
            }
        });
    };
    Object.defineProperty(LocationService.prototype, "currentHostCooldownMs", {
        get: function () {
            return this.isInFastShutdown ? this.fastShutdownHostCooldownMs : this.hostCooldownMs;
        },
        enumerable: true,
        configurable: true
    });
    LocationService.prototype.startFastShutdown = function () {
        if (!this.isInFastShutdown) {
            this.isInFastShutdown = true;
            this.logger.info('Starting fast shutdown');
            this.updateHostCooldownTimeouts();
        }
    };
    LocationService.prototype.stopFastShutdown = function () {
        if (this.isInFastShutdown) {
            this.isInFastShutdown = false;
            this.logger.info('Stopping fast shutdown');
        }
    };
    LocationService.prototype.updateHostCooldownTimeouts = function () {
        var _this = this;
        for (var hostId in this.hosts) {
            this.hosts[hostId].done(function (host) {
                if (!host.hasActiveServices) {
                    _this.startHostCooldown(host);
                }
            }, function (err) {
                _this.logger.error("Error getting host: " + err.message);
            });
        }
    };
    LocationService.prototype.getHost = function (hostId) {
        if (!hostId) {
            throw new Error(libraryResourceStrings_1.LibraryResourceStrings.variableIsNotDefined('hostid'));
        }
        if (!this.hosts.hasOwnProperty(hostId)) {
            throw new Error(libraryResourceStrings_1.LibraryResourceStrings.unknownHost(hostId));
        }
        return this.hosts[hostId];
    };
    LocationService.prototype.startHostCooldown = function (host) {
        host.hasActiveServices = false;
        // Start cooldown unless the host is already shutting down
        if (!host.shutdown) {
            host.setCooldownTimeout(this.shutdownInactiveHost.bind(this), this.currentHostCooldownMs, host);
        }
    };
    LocationService.prototype.shutdownInactiveHost = function (host) {
        if (host.hasActiveServices || host.shutdown) {
            // The host become active again or it has already shutdown
            return;
        }
        var currentTime = new Date().getTime();
        if (host.pendingStartServiceRequestCount === 0
            && host.lastAccessTimeMs < currentTime - this.currentHostCooldownMs) {
            // The host is inactive and no service has started there since the cooldown began.
            this.stopHost(host, 'inactivity').done();
        }
        else {
            // The host is inactive but there was some service started there during the cooldown period.
            // Start another cooldown period to account for the new service.
            this.startHostCooldown(host);
        }
    };
    LocationService.prototype.stopHost = function (host, reason) {
        this.logger.info(libraryResourceStrings_1.LibraryResourceStrings.stoppingHost(host.getId(), host.hostProcess.pid.toString(), reason));
        this.forgetHost(host);
        // No need to fire host cooldown timer if the host is exiting right now.
        host.clearCooldownTimeout();
        var hostProcessExit = q.defer();
        host.hostProcess.once('exit', function (code) { return hostProcessExit.resolve(code); });
        return host.endPoint.promise
            .then(function (endPoint) { return endPoint.sendNotification(hostInfo_1.HostMethod.Exit); })
            .then(function () { return hostProcessExit.promise; });
    };
    LocationService.prototype.isExternalClient = function (clientInfo) {
        // External client is the one that doesn't run in any of Service Hub processes.
        return clientInfo && clientInfo.pid && clientInfo.pid !== process.pid && this.hostPids.indexOf(clientInfo.pid) === -1;
    };
    return LocationService;
}());
exports.LocationService = LocationService;
var LocationServiceProxy = (function () {
    function LocationServiceProxy(endPoint) {
        this.endPoint = endPoint;
        if (!endPoint) {
            throw new common_1.ServiceHubError(common_1.ErrorKind.InvalidArgument, libraryResourceStrings_1.LibraryResourceStrings.variablesAreNotDefined('endPoint'));
        }
    }
    LocationServiceProxy.prototype.locate = function (serviceDescriptor, clientInfo) {
        // To support backward compat between client and hub controller,
        // only use service descriptor if the service name alone is not enough.
        var isServiceNameOnly = (new serviceDescriptor_1.ServiceDescriptor(serviceDescriptor)).isServiceNameOnly();
        var serviceNameOrDescriptor = isServiceNameOnly ? serviceDescriptor.name : serviceDescriptor;
        return q(this.endPoint.sendRequest('locate', [serviceNameOrDescriptor, clientInfo]));
    };
    LocationServiceProxy.prototype.stop = function () {
        return q(this.endPoint.sendNotification('exit', ['explicit request from the client']))
            .catch(function (err) {
            // If the controller has already closed, ignore the json rpc error.
            if (err.code !== ec.ENOENT.code) {
                throw err;
            }
        });
    };
    LocationServiceProxy.prototype.getSessionId = function () {
        return q(this.endPoint.sendRequest('getSessionId'));
    };
    LocationServiceProxy.prototype.dispose = function () {
        this.endPoint.dispose();
    };
    LocationServiceProxy.prototype.startHeapDiff = function () {
        return q(this.endPoint.sendRequest('startHeapDiff'));
    };
    LocationServiceProxy.prototype.endHeapDiff = function () {
        return q(this.endPoint.sendRequest('endHeapDiff'));
    };
    LocationServiceProxy.prototype.runGC = function () {
        return q(this.endPoint.sendRequest('runGC'));
    };
    LocationServiceProxy.prototype.captureHeapDump = function (filePath) {
        return q(this.endPoint.sendRequest('captureHeapDump', [filePath]));
    };
    LocationServiceProxy.prototype.getHubControllerPid = function () {
        return q(this.endPoint.sendRequest('getHubControllerPid'));
    };
    return LocationServiceProxy;
}());
exports.LocationServiceProxy = LocationServiceProxy;

//# sourceMappingURL=locationService.js.map
// SIG // Begin signature block
// SIG // MIIhyAYJKoZIhvcNAQcCoIIhuTCCIbUCAQExDzANBglg
// SIG // hkgBZQMEAgEFADB3BgorBgEEAYI3AgEEoGkwZzAyBgor
// SIG // BgEEAYI3AgEeMCQCAQEEEBDgyQbOONQRoqMAEEvTUJAC
// SIG // AQACAQACAQACAQACAQAwMTANBglghkgBZQMEAgEFAAQg
// SIG // nS+lEWN812nDHb9QB7FQIpATKqKDFqnKEjErQ2SJRNmg
// SIG // ggtWMIIE3jCCA8agAwIBAgITMwAAAcy1W0IXB2ATEQAA
// SIG // AAABzDANBgkqhkiG9w0BAQsFADB+MQswCQYDVQQGEwJV
// SIG // UzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMH
// SIG // UmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBv
// SIG // cmF0aW9uMSgwJgYDVQQDEx9NaWNyb3NvZnQgQ29kZSBT
// SIG // aWduaW5nIFBDQSAyMDEwMB4XDTE3MDkxMjE4MDcwNloX
// SIG // DTE4MDkxMjE4MDcwNlowdDELMAkGA1UEBhMCVVMxEzAR
// SIG // BgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1v
// SIG // bmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlv
// SIG // bjEeMBwGA1UEAxMVTWljcm9zb2Z0IENvcnBvcmF0aW9u
// SIG // MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA
// SIG // qZB1moyDMhvorMTex1h+UmWZ52gS7QV0SxKYiTA2P3Ep
// SIG // m3JVmRehPh979B7y6IQgC1C1jrZvtxI21cmxI2KOfkIu
// SIG // 6QywYHZohyxI1JMbfDeVZVCHaafQKW+IZeKZwjAMl2Cw
// SIG // GqeLCmRY3bNRsq5x9ldPKLQX5dZgsCuGeSgrWfQbvlw5
// SIG // 9LTN/Ds5kGkZf2dMSzu6n1lVGgY/7KT75ZCq/p7p4Eru
// SIG // STIPMUnCks35BzTHKwAwEP0QyhnsJGPq3a2Kk/XGmgiU
// SIG // Is9Co0CnbcwsXdXxQceTdcovfituYLlo8qowRTX575Lh
// SIG // dSSJQFyepgmTN94YvAm0bUWaQsK5czBxiwIDAQABo4IB
// SIG // XTCCAVkwHwYDVR0lBBgwFgYKKwYBBAGCNz0GAQYIKwYB
// SIG // BQUHAwMwHQYDVR0OBBYEFFlVxIKPLL3blp451S/Ro/0y
// SIG // ArJ/MDQGA1UdEQQtMCukKTAnMQ0wCwYDVQQLEwRNT1BS
// SIG // MRYwFAYDVQQFEw0yMzA4NjUrMjQyNDA2MB8GA1UdIwQY
// SIG // MBaAFOb8X3u7IgBY5HJOtfQhdCMy5u+sMFYGA1UdHwRP
// SIG // ME0wS6BJoEeGRWh0dHA6Ly9jcmwubWljcm9zb2Z0LmNv
// SIG // bS9wa2kvY3JsL3Byb2R1Y3RzL01pY0NvZFNpZ1BDQV8y
// SIG // MDEwLTA3LTA2LmNybDBaBggrBgEFBQcBAQROMEwwSgYI
// SIG // KwYBBQUHMAKGPmh0dHA6Ly93d3cubWljcm9zb2Z0LmNv
// SIG // bS9wa2kvY2VydHMvTWljQ29kU2lnUENBXzIwMTAtMDct
// SIG // MDYuY3J0MAwGA1UdEwEB/wQCMAAwDQYJKoZIhvcNAQEL
// SIG // BQADggEBANGT7iex7letmRmMI2tjEMw591UYclg78am3
// SIG // zuDKljBRU8yY8BJTGCvoGpikCbUB0SNGoXj3/2XOTlse
// SIG // YC5zfrAJekrn1313An/RxRGJsD8y7Ya38xAJ244R01Yd
// SIG // 9IVXAin+6rhRv0PufFSfH7mdyeAMDE4Y0Dj3j6pw8Cob
// SIG // tPMrYXtwihbvO/faO/afni6lv4RlCSU5sdIgCdq42Q/k
// SIG // J31KgwF17IJ30LmgQyumPqUe9UsDdCWIo2BiJc2NOvaR
// SIG // ChsDvWdCyaOrmpP9elruUdb5hm5M5wBYLEPT+kTIAx6f
// SIG // 78TM4c2wyev6XQjaR4FXESduccHGT35ECK8c7quVDqMw
// SIG // ggZwMIIEWKADAgECAgphDFJMAAAAAAADMA0GCSqGSIb3
// SIG // DQEBCwUAMIGIMQswCQYDVQQGEwJVUzETMBEGA1UECBMK
// SIG // V2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwG
// SIG // A1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMTIwMAYD
// SIG // VQQDEylNaWNyb3NvZnQgUm9vdCBDZXJ0aWZpY2F0ZSBB
// SIG // dXRob3JpdHkgMjAxMDAeFw0xMDA3MDYyMDQwMTdaFw0y
// SIG // NTA3MDYyMDUwMTdaMH4xCzAJBgNVBAYTAlVTMRMwEQYD
// SIG // VQQIEwpXYXNoaW5ndG9uMRAwDgYDVQQHEwdSZWRtb25k
// SIG // MR4wHAYDVQQKExVNaWNyb3NvZnQgQ29ycG9yYXRpb24x
// SIG // KDAmBgNVBAMTH01pY3Jvc29mdCBDb2RlIFNpZ25pbmcg
// SIG // UENBIDIwMTAwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAw
// SIG // ggEKAoIBAQDpDmRQeWe1xOP9CQBMnpSs91Zo6kTYz8VY
// SIG // T6mldnxtRbrTOZK0pB75+WWC5BfSj/1EnAjoZZPOLFWE
// SIG // v30I4y4rqEErGLeiS25JTGsVB97R0sKJHnGUzbV/S7Sv
// SIG // CNjMiNZrF5Q6k84mP+zm/jSYV9UdXUn2siou1YW7WT/4
// SIG // kLQrg3TKK7M7RuPwRknBF2ZUyRy9HcRVYldy+Ge5JSA0
// SIG // 3l2mpZVeqyiAzdWynuUDtWPTshTIwciKJgpZfwfs/w7t
// SIG // gBI1TBKmvlJb9aba4IsLSHfWhUfVELnG6Krui2otBVxg
// SIG // xrQqW5wjHF9F4xoUHm83yxkzgGqJTaNqZmN4k9Uwz5Uf
// SIG // AgMBAAGjggHjMIIB3zAQBgkrBgEEAYI3FQEEAwIBADAd
// SIG // BgNVHQ4EFgQU5vxfe7siAFjkck619CF0IzLm76wwGQYJ
// SIG // KwYBBAGCNxQCBAweCgBTAHUAYgBDAEEwCwYDVR0PBAQD
// SIG // AgGGMA8GA1UdEwEB/wQFMAMBAf8wHwYDVR0jBBgwFoAU
// SIG // 1fZWy4/oolxiaNE9lJBb186aGMQwVgYDVR0fBE8wTTBL
// SIG // oEmgR4ZFaHR0cDovL2NybC5taWNyb3NvZnQuY29tL3Br
// SIG // aS9jcmwvcHJvZHVjdHMvTWljUm9vQ2VyQXV0XzIwMTAt
// SIG // MDYtMjMuY3JsMFoGCCsGAQUFBwEBBE4wTDBKBggrBgEF
// SIG // BQcwAoY+aHR0cDovL3d3dy5taWNyb3NvZnQuY29tL3Br
// SIG // aS9jZXJ0cy9NaWNSb29DZXJBdXRfMjAxMC0wNi0yMy5j
// SIG // cnQwgZ0GA1UdIASBlTCBkjCBjwYJKwYBBAGCNy4DMIGB
// SIG // MD0GCCsGAQUFBwIBFjFodHRwOi8vd3d3Lm1pY3Jvc29m
// SIG // dC5jb20vUEtJL2RvY3MvQ1BTL2RlZmF1bHQuaHRtMEAG
// SIG // CCsGAQUFBwICMDQeMiAdAEwAZQBnAGEAbABfAFAAbwBs
// SIG // AGkAYwB5AF8AUwB0AGEAdABlAG0AZQBuAHQALiAdMA0G
// SIG // CSqGSIb3DQEBCwUAA4ICAQAadO9XTyl7xBaFeLhQ0yL8
// SIG // CZ2sgpf4NP8qLJeVEuXkv8+/k8jjNKnbgbjcHgC+0jVv
// SIG // r+V/eZV35QLU8evYzU4eG2GiwlojGvCMqGJRRWcI4z88
// SIG // HpP4MIUXyDlAptcOsyEp5aWhaYwik8x0mOehR0PyU6zA
// SIG // DzBpf/7SJSBtb2HT3wfV2XIALGmGdj1R26Y5SMk3YW0H
// SIG // 3VMZy6fWYcK/4oOrD+Brm5XWfShRsIlKUaSabMi3H0oa
// SIG // Dmmp19zBftFJcKq2rbtyR2MX+qbWoqaG7KgQRJtjtrJp
// SIG // iQbHRoZ6GD/oxR0h1Xv5AiMtxUHLvx1MyBbvsZx//CJL
// SIG // SYpuFeOmf3Zb0VN5kYWd1dLbPXM18zyuVLJSR2rAqhOV
// SIG // 0o4R2plnXjKM+zeF0dx1hZyHxlpXhcK/3Q2PjJst67Tu
// SIG // zyfTtV5p+qQWBAGnJGdzz01Ptt4FVpd69+lSTfR3BU+F
// SIG // xtgL8Y7tQgnRDXbjI1Z4IiY2vsqxjG6qHeSF2kczYo+k
// SIG // yZEzX3EeQK+YZcki6EIhJYocLWDZN4lBiSoWD9dhPJRo
// SIG // YFLv1keZoIBA7hWBdz6c4FMYGlAdOJWbHmYzEyc5F3iH
// SIG // Ns5Ow1+y9T1HU7bg5dsLYT0q15IszjdaPkBCMaQfEAjC
// SIG // Vpy/JF1RAp1qedIX09rBlI4HeyVxRKsGaubUxt8jmpZ1
// SIG // xTGCFcowghXGAgEBMIGVMH4xCzAJBgNVBAYTAlVTMRMw
// SIG // EQYDVQQIEwpXYXNoaW5ndG9uMRAwDgYDVQQHEwdSZWRt
// SIG // b25kMR4wHAYDVQQKExVNaWNyb3NvZnQgQ29ycG9yYXRp
// SIG // b24xKDAmBgNVBAMTH01pY3Jvc29mdCBDb2RlIFNpZ25p
// SIG // bmcgUENBIDIwMTACEzMAAAHMtVtCFwdgExEAAAAAAcww
// SIG // DQYJYIZIAWUDBAIBBQCggbwwGQYJKoZIhvcNAQkDMQwG
// SIG // CisGAQQBgjcCAQQwHAYKKwYBBAGCNwIBCzEOMAwGCisG
// SIG // AQQBgjcCARUwLwYJKoZIhvcNAQkEMSIEIEStIvhSYSXR
// SIG // ydQAytuK2hrAlEbYnNl9YXYwk6/ioh4uMFAGCisGAQQB
// SIG // gjcCAQwxQjBAoCaAJABsAG8AYwBhAHQAaQBvAG4AUwBl
// SIG // AHIAdgBpAGMAZQAuAGoAc6EWgBRodHRwOi8vbWljcm9z
// SIG // b2Z0LmNvbTANBgkqhkiG9w0BAQEFAASCAQA8Utg5ZwPs
// SIG // GkjOMuOu7jyRXNMz2H+/BOUQJx/Qe+mTBm+yirqQ47sw
// SIG // nN6LTfiekh+wYUIdmoX7EE/XFdy99x3hA5bWL9NCsMCP
// SIG // +5qK5Ki07BEfDwtcdyCH26uL32OQxtXYUqxk/wFDh47o
// SIG // MQHWOHcLnGeq7jHUPjranBhpxvP5NuAzxkR/e1H4pIOA
// SIG // jo/AHiw8vQqLxqLlqa1c9YmOD5KAK9phCseZeY39BkQy
// SIG // pgWKi5fBwpxxxOoQHMogWhTtFTJY+oR+s1m+sSpKcfMh
// SIG // 6WtN6q1tpNhs6FFHtI68ReTXIKNyvWdpygkoiDEEnaMe
// SIG // 4Qk81abBRJxDTmWX6mhL4rXHoYITRjCCE0IGCisGAQQB
// SIG // gjcDAwExghMyMIITLgYJKoZIhvcNAQcCoIITHzCCExsC
// SIG // AQMxDzANBglghkgBZQMEAgEFADCCATwGCyqGSIb3DQEJ
// SIG // EAEEoIIBKwSCAScwggEjAgEBBgorBgEEAYRZCgMBMDEw
// SIG // DQYJYIZIAWUDBAIBBQAEIO9b69eOiOHgKBalNFVP7t+6
// SIG // Rn5wD4OjrKxJE5b7/Q2VAgZae0pmZj0YEzIwMTgwMjEz
// SIG // MDUxMjM0LjY4MVowBwIBAYACAfSggbikgbUwgbIxCzAJ
// SIG // BgNVBAYTAlVTMRMwEQYDVQQIEwpXYXNoaW5ndG9uMRAw
// SIG // DgYDVQQHEwdSZWRtb25kMR4wHAYDVQQKExVNaWNyb3Nv
// SIG // ZnQgQ29ycG9yYXRpb24xDDAKBgNVBAsTA0FPQzEnMCUG
// SIG // A1UECxMebkNpcGhlciBEU0UgRVNOOjEyQjQtMkQ1Ri04
// SIG // N0Q0MSUwIwYDVQQDExxNaWNyb3NvZnQgVGltZS1TdGFt
// SIG // cCBTZXJ2aWNloIIOyjCCBnEwggRZoAMCAQICCmEJgSoA
// SIG // AAAAAAIwDQYJKoZIhvcNAQELBQAwgYgxCzAJBgNVBAYT
// SIG // AlVTMRMwEQYDVQQIEwpXYXNoaW5ndG9uMRAwDgYDVQQH
// SIG // EwdSZWRtb25kMR4wHAYDVQQKExVNaWNyb3NvZnQgQ29y
// SIG // cG9yYXRpb24xMjAwBgNVBAMTKU1pY3Jvc29mdCBSb290
// SIG // IENlcnRpZmljYXRlIEF1dGhvcml0eSAyMDEwMB4XDTEw
// SIG // MDcwMTIxMzY1NVoXDTI1MDcwMTIxNDY1NVowfDELMAkG
// SIG // A1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAO
// SIG // BgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29m
// SIG // dCBDb3Jwb3JhdGlvbjEmMCQGA1UEAxMdTWljcm9zb2Z0
// SIG // IFRpbWUtU3RhbXAgUENBIDIwMTAwggEiMA0GCSqGSIb3
// SIG // DQEBAQUAA4IBDwAwggEKAoIBAQCpHQ28dxGKOiDs/BOX
// SIG // 9fp/aZRrdFQQ1aUKAIKF++18aEssX8XD5WHCdrc+Zitb
// SIG // 8BVTJwQxH0EbGpUdzgkTjnxhMFmxMEQP8WCIhFRDDNdN
// SIG // uDgIs0Ldk6zWczBXJoKjRQ3Q6vVHgc2/JGAyWGBG8lhH
// SIG // hjKEHnRhZ5FfgVSxz5NMksHEpl3RYRNuKMYa+YaAu99h
// SIG // /EbBJx0kZxJyGiGKr0tkiVBisV39dx898Fd1rL2KQk1A
// SIG // UdEPnAY+Z3/1ZsADlkR+79BL/W7lmsqxqPJ6Kgox8NpO
// SIG // BpG2iAg16HgcsOmZzTznL0S6p/TcZL2kAcEgCZN4zfy8
// SIG // wMlEXV4WnAEFTyJNAgMBAAGjggHmMIIB4jAQBgkrBgEE
// SIG // AYI3FQEEAwIBADAdBgNVHQ4EFgQU1WM6XIoxkPNDe3xG
// SIG // G8UzaFqFbVUwGQYJKwYBBAGCNxQCBAweCgBTAHUAYgBD
// SIG // AEEwCwYDVR0PBAQDAgGGMA8GA1UdEwEB/wQFMAMBAf8w
// SIG // HwYDVR0jBBgwFoAU1fZWy4/oolxiaNE9lJBb186aGMQw
// SIG // VgYDVR0fBE8wTTBLoEmgR4ZFaHR0cDovL2NybC5taWNy
// SIG // b3NvZnQuY29tL3BraS9jcmwvcHJvZHVjdHMvTWljUm9v
// SIG // Q2VyQXV0XzIwMTAtMDYtMjMuY3JsMFoGCCsGAQUFBwEB
// SIG // BE4wTDBKBggrBgEFBQcwAoY+aHR0cDovL3d3dy5taWNy
// SIG // b3NvZnQuY29tL3BraS9jZXJ0cy9NaWNSb29DZXJBdXRf
// SIG // MjAxMC0wNi0yMy5jcnQwgaAGA1UdIAEB/wSBlTCBkjCB
// SIG // jwYJKwYBBAGCNy4DMIGBMD0GCCsGAQUFBwIBFjFodHRw
// SIG // Oi8vd3d3Lm1pY3Jvc29mdC5jb20vUEtJL2RvY3MvQ1BT
// SIG // L2RlZmF1bHQuaHRtMEAGCCsGAQUFBwICMDQeMiAdAEwA
// SIG // ZQBnAGEAbABfAFAAbwBsAGkAYwB5AF8AUwB0AGEAdABl
// SIG // AG0AZQBuAHQALiAdMA0GCSqGSIb3DQEBCwUAA4ICAQAH
// SIG // 5ohRDeLG4Jg/gXEDPZ2joSFvs+umzPUxvs8F4qn++ldt
// SIG // GTCzwsVmyWrf9efweL3HqJ4l4/m87WtUVwgrUYJEEvu5
// SIG // U4zM9GASinbMQEBBm9xcF/9c+V4XNZgkVkt070IQyK+/
// SIG // f8Z/8jd9Wj8c8pl5SpFSAK84Dxf1L3mBZdmptWvkx872
// SIG // ynoAb0swRCQiPM/tA6WWj1kpvLb9BOFwnzJKJ/1Vry/+
// SIG // tuWOM7tiX5rbV0Dp8c6ZZpCM/2pif93FSguRJuI57BlK
// SIG // cWOdeyFtw5yjojz6f32WapB4pm3S4Zz5Hfw42JT0xqUK
// SIG // loakvZ4argRCg7i1gJsiOCC1JeVk7Pf0v35jWSUPei45
// SIG // V3aicaoGig+JFrphpxHLmtgOR5qAxdDNp9DvfYPw4Ttx
// SIG // Cd9ddJgiCGHasFAeb73x4QDf5zEHpJM692VHeOj4qEir
// SIG // 995yfmFrb3epgcunCaw5u+zGy9iCtHLNHfS4hQEegPsb
// SIG // iSpUObJb2sgNVZl6h3M7COaYLeqN4DMuEin1wC9UJyH3
// SIG // yKxO2ii4sanblrKnQqLJzxlBTeCG+SqaoxFmMNO7dDJL
// SIG // 32N79ZmKLxvHIa9Zta7cRDyXUHHXodLFVeNp3lfB0d4w
// SIG // wP3M5k37Db9dT+mdHhk4L7zPWAUu7w2gUDXa7wknHNWz
// SIG // fjUeCLraNtvTX4/edIhJEjCCBNkwggPBoAMCAQICEzMA
// SIG // AACnZF3FKA8BPUQAAAAAAKcwDQYJKoZIhvcNAQELBQAw
// SIG // fDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0
// SIG // b24xEDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1p
// SIG // Y3Jvc29mdCBDb3Jwb3JhdGlvbjEmMCQGA1UEAxMdTWlj
// SIG // cm9zb2Z0IFRpbWUtU3RhbXAgUENBIDIwMTAwHhcNMTYw
// SIG // OTA3MTc1NjUyWhcNMTgwOTA3MTc1NjUyWjCBsjELMAkG
// SIG // A1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAO
// SIG // BgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29m
// SIG // dCBDb3Jwb3JhdGlvbjEMMAoGA1UECxMDQU9DMScwJQYD
// SIG // VQQLEx5uQ2lwaGVyIERTRSBFU046MTJCNC0yRDVGLTg3
// SIG // RDQxJTAjBgNVBAMTHE1pY3Jvc29mdCBUaW1lLVN0YW1w
// SIG // IFNlcnZpY2UwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAw
// SIG // ggEKAoIBAQCm6hpQwF9P0lP5oewEfA3XIFcxIVHYx+4D
// SIG // Ci54zosuIiNrljYQHwpReoXnXRT+c7LX0nxjVcEKuMaU
// SIG // NOi4idkXnAmxGKGRP0NWVVbZW8VP1oN+5OgQiBtMehuQ
// SIG // otS1AtPR+L+bzv81atUujkyTRnqzfU5S0BgR2MyXzEyU
// SIG // 5HKLUPzq0lIJEDiDEbiWAzE4XEGNOimHEVgTow6tfa3e
// SIG // +uZuytC4oXNtvrWppWdJawd8eYi0ZjbyMSc4FOI1H8En
// SIG // XXjI4ioya2eBRlMF1ntDNWpEMO27Ie03SX+yRAmb2lnA
// SIG // Kz6S+A7AJksXiu8I01TnjAuPio1S9qB5qE9mBjK5iyrx
// SIG // AgMBAAGjggEbMIIBFzAdBgNVHQ4EFgQUfA1KC337T/9e
// SIG // ECw9eW8gTUJQiF0wHwYDVR0jBBgwFoAU1WM6XIoxkPND
// SIG // e3xGG8UzaFqFbVUwVgYDVR0fBE8wTTBLoEmgR4ZFaHR0
// SIG // cDovL2NybC5taWNyb3NvZnQuY29tL3BraS9jcmwvcHJv
// SIG // ZHVjdHMvTWljVGltU3RhUENBXzIwMTAtMDctMDEuY3Js
// SIG // MFoGCCsGAQUFBwEBBE4wTDBKBggrBgEFBQcwAoY+aHR0
// SIG // cDovL3d3dy5taWNyb3NvZnQuY29tL3BraS9jZXJ0cy9N
// SIG // aWNUaW1TdGFQQ0FfMjAxMC0wNy0wMS5jcnQwDAYDVR0T
// SIG // AQH/BAIwADATBgNVHSUEDDAKBggrBgEFBQcDCDANBgkq
// SIG // hkiG9w0BAQsFAAOCAQEAmsYkS+eXslIBZIcP4kKTKFZ5
// SIG // dvT5ChVnTXoOiYA8PzNC3o5y8lym83izubCF0o8l7duK
// SIG // veEsfVZgBBLPJ/NjePhGVFRKFtpr6ly7+4Z6bF5/TXNi
// SIG // oDadsN6z6c8SYoz68JxsJAxriC6Rl77fTjKMXG4nhCd5
// SIG // m53L3+jsEQsACVx6L2ol9tL2OiqHbUd2zFWvTrbx1Xoa
// SIG // s/mcHQhIKP1x/14HmyVCsKP4C/1h0l+6dOhh1fPi4ES/
// SIG // KQ3jivBtXYxa4uUODYEH0SuO0nlQma0Boss1Abq+AEKD
// SIG // I3G2HWCHqoxb/nvtcIYOCHG1V4UvlBAjbbQfvKNGt+UW
// SIG // S67wrra6TqGCA3QwggJcAgEBMIHioYG4pIG1MIGyMQsw
// SIG // CQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQ
// SIG // MA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWljcm9z
// SIG // b2Z0IENvcnBvcmF0aW9uMQwwCgYDVQQLEwNBT0MxJzAl
// SIG // BgNVBAsTHm5DaXBoZXIgRFNFIEVTTjoxMkI0LTJENUYt
// SIG // ODdENDElMCMGA1UEAxMcTWljcm9zb2Z0IFRpbWUtU3Rh
// SIG // bXAgU2VydmljZaIlCgEBMAkGBSsOAwIaBQADFQDkgi6d
// SIG // MjZtdAAyDx7BIbQN6wx32aCBwTCBvqSBuzCBuDELMAkG
// SIG // A1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAO
// SIG // BgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29m
// SIG // dCBDb3Jwb3JhdGlvbjEMMAoGA1UECxMDQU9DMScwJQYD
// SIG // VQQLEx5uQ2lwaGVyIE5UUyBFU046MjY2NS00QzNGLUM1
// SIG // REUxKzApBgNVBAMTIk1pY3Jvc29mdCBUaW1lIFNvdXJj
// SIG // ZSBNYXN0ZXIgQ2xvY2swDQYJKoZIhvcNAQEFBQACBQDe
// SIG // LIMPMCIYDzIwMTgwMjEyMjExODA3WhgPMjAxODAyMTMy
// SIG // MTE4MDdaMHQwOgYKKwYBBAGEWQoEATEsMCowCgIFAN4s
// SIG // gw8CAQAwBwIBAAICDDswBwIBAAICGREwCgIFAN4t1I8C
// SIG // AQAwNgYKKwYBBAGEWQoEAjEoMCYwDAYKKwYBBAGEWQoD
// SIG // AaAKMAgCAQACAxbjYKEKMAgCAQACAwehIDANBgkqhkiG
// SIG // 9w0BAQUFAAOCAQEAdrabiRUN1kfNS4IZVJg3s43AWwL2
// SIG // xHy84w0F2DZfpPDw0nRKQpd6AtRwQaXGNa4q3w0UlmkA
// SIG // u0aDm271c/WkBsuw1eqbjJybQgW5aVsh7IqRLwaBTYkZ
// SIG // 8dpM0+K9eFaro1vA+MvKSAtdhovPmRoR2ZEpsiBMvnfC
// SIG // yx+r8CmIjBL/1h4gtfcdLQNevVbi/unMOUgWaR7MmRY1
// SIG // 206obRtXDJsYW4uCkhTBBC8pDRHd33HrmdYpE87g7qIi
// SIG // p4IFoYVMVLYStVpZYKbiLWVz8yZDpW/IkGz/kEOE3jFY
// SIG // /j1XRgCdZ4pHoayHBjT++jxro65i4bvFvcz9o3+BxC+R
// SIG // FGpH3TGCAvUwggLxAgEBMIGTMHwxCzAJBgNVBAYTAlVT
// SIG // MRMwEQYDVQQIEwpXYXNoaW5ndG9uMRAwDgYDVQQHEwdS
// SIG // ZWRtb25kMR4wHAYDVQQKExVNaWNyb3NvZnQgQ29ycG9y
// SIG // YXRpb24xJjAkBgNVBAMTHU1pY3Jvc29mdCBUaW1lLVN0
// SIG // YW1wIFBDQSAyMDEwAhMzAAAAp2RdxSgPAT1EAAAAAACn
// SIG // MA0GCWCGSAFlAwQCAQUAoIIBMjAaBgkqhkiG9w0BCQMx
// SIG // DQYLKoZIhvcNAQkQAQQwLwYJKoZIhvcNAQkEMSIEIPdL
// SIG // 6ZTZlKOEQp4zP3W+8RvEkBnuAErT60lh3owTPYWxMIHi
// SIG // BgsqhkiG9w0BCRACDDGB0jCBzzCBzDCBsQQU5IIunTI2
// SIG // bXQAMg8ewSG0DesMd9kwgZgwgYCkfjB8MQswCQYDVQQG
// SIG // EwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UE
// SIG // BxMHUmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0IENv
// SIG // cnBvcmF0aW9uMSYwJAYDVQQDEx1NaWNyb3NvZnQgVGlt
// SIG // ZS1TdGFtcCBQQ0EgMjAxMAITMwAAAKdkXcUoDwE9RAAA
// SIG // AAAApzAWBBSkAxM4uHhziqKssFdcATBGcjYnJTANBgkq
// SIG // hkiG9w0BAQsFAASCAQAMJ8x65PbSqBp8czEHxfuursZ2
// SIG // 9/+JMFOj/JPxr928V35RFnqsNi5gDn+GpXguidtJg8Zq
// SIG // LDQoRruHvnJeh2Cl2iMP9hfe3Zfl41KIibwhYvlSEZIR
// SIG // nFGcQlKMrSaC5B8xvr5xa+iGOa9askTz9JxVs2shdhmU
// SIG // w4P/5OvLLCjJdhHodRbGDaP7/hxBu4FiVEVcWVpGXeE5
// SIG // 2ZRcW1e7VLjXRrSdkwTpvMZzArDMxNCzKujlxrqUY6Op
// SIG // IGvv31QzDgdWmHxTfiDofUeTUgR2UwJMMu+C+WpLcwcT
// SIG // C8rvGruxko9yOtdNOX0YI5ipW63RquGqBe4LQsbMOD+f
// SIG // ewG8RXcA
// SIG // End signature block
