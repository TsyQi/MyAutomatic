/*!---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var _1 = require("./");
var path = require("path");
;
var ErrorInformation = (function () {
    function ErrorInformation(options) {
        if (!options.rawError) {
            throw new Error("You must provide an error to process");
        }
        this._rawError = options.rawError;
        this._errorType = options.errorType;
        this._packageInfo = options.packageInfo;
        this._exeName = defaultValue(path.basename(process.execPath), options.exeName);
        this._errorReporter = options.errorReporter;
        this._pathMode = defaultValue(_1.pathMode.defaultMode, options.mode);
    }
    ErrorInformation.prototype.getStructuredStack = function () {
        if (!this._structuredError) {
            try {
                this._structuredError = this.rawToStructured(this._rawError.stack);
            }
            catch (e) {
                if (this.errorReporter) {
                    this.errorReporter.emitInternalError(e, this._rawError, "");
                }
                throw e;
            }
        }
        return this._structuredError;
    };
    ErrorInformation.prototype.getStandardStack = function () {
        if (!this._standardStack) {
            try {
                this._standardStack = _1.structuredToStandard(this.getStructuredStack());
            }
            catch (e) {
                if (this.errorReporter) {
                    this.errorReporter.emitInternalError(e, this._rawError, "");
                }
                throw e;
            }
        }
        return this._standardStack;
    };
    ErrorInformation.prototype.getVerboseStack = function () {
        if (!this._verboseStack) {
            try {
                this._verboseStack = _1.structuredToSemiWatson(this.getStructuredStack());
            }
            catch (e) {
                if (this.errorReporter) {
                    this.errorReporter.emitInternalError(e, this._rawError, "");
                }
                throw e;
            }
        }
        return this._verboseStack;
    };
    Object.defineProperty(ErrorInformation.prototype, "errorName", {
        get: function () {
            return this._rawError.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ErrorInformation.prototype, "errorMessage", {
        get: function () {
            return this._rawError.message;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ErrorInformation.prototype, "errorType", {
        get: function () {
            return this._errorType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ErrorInformation.prototype, "rawError", {
        get: function () {
            return this._rawError;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ErrorInformation.prototype, "packageInfo", {
        get: function () {
            return this._packageInfo;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ErrorInformation.prototype, "exeName", {
        get: function () {
            return this._exeName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ErrorInformation.prototype, "errorReporter", {
        get: function () {
            return this._errorReporter;
        },
        enumerable: true,
        configurable: true
    });
    ErrorInformation.prototype.rawToStructured = function (raw) {
        var stackProc = new _1.StackProcessor({
            appRoot: this.packageInfo.packageJsonFullPath,
            errorReporter: this.errorReporter,
            packageInfo: this.packageInfo,
            mode: this._pathMode });
        var originalLines = raw.split("\n");
        var structuredStack;
        try {
            structuredStack = stackProc.parseFirstLine(originalLines[0]);
        }
        catch (e) {
            structuredStack = { ErrorType: this.errorName, ErrorMessage: this.errorMessage, Stack: [] };
        }
        for (var i = 1; i < originalLines.length; i++) {
            var currentFrame = void 0;
            try {
                currentFrame = stackProc.parseStackLine(originalLines[i], true);
            }
            catch (e) {
                if (this.errorReporter) {
                    this.errorReporter.emitInternalError(e, this.rawError, originalLines[i]);
                }
                currentFrame = {
                    RelativePath: "UNSUPPORTED",
                    extra: {
                        failedToParse: true,
                        rawString: originalLines[i]
                    }
                };
            }
            structuredStack.Stack.push(currentFrame);
        }
        return structuredStack;
    };
    return ErrorInformation;
}());
exports.ErrorInformation = ErrorInformation;
function setStackTraceLimit(limit) {
    try {
        Error.stackTraceLimit(limit);
    }
    catch (e) {
        var err = Error;
        err.stackTraceLimit = limit;
    }
}
exports.setStackTraceLimit = setStackTraceLimit;
function coerceToError(e) {
    if (e instanceof Error) {
        return e;
    }
    return new NonError(e);
}
exports.coerceToError = coerceToError;
var NonError = (function (_super) {
    __extends(NonError, _super);
    function NonError(input) {
        _super.call(this);
        this.name = "NonError";
        if (input.message) {
            this.message = input.message;
        }
        else {
            this.message = JSON.stringify(input);
        }
        if (input.stack) {
            this.stack = input.stack;
        }
        else {
            var header = this.name + ": " + this.message;
            this.stack = header + "\nat NonError";
        }
        this.originalObject = input;
    }
    return NonError;
}(Error));
exports.NonError = NonError;
function defaultValue(defaultValue, actual, strict) {
    if (strict === void 0) { strict = true; }
    if ((strict && actual === undefined) || (!strict && !actual)) {
        return defaultValue;
    }
    return actual;
}
exports.defaultValue = defaultValue;
