/*!---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
"use strict";
var try_all_1 = require("./try-all");
var path = require("path");
var advanced_1 = require("./advanced");
var events_1 = require("events");
var INTERNAL_ERROR = "internalError";
var ERROR_REPORTING_STARTED = "reportingStarted";
var ERROR_REPORTING_FINISHED = "reportingFinished";
var ErrorReporter = (function () {
    function ErrorReporter(config) {
        this._packageInfo = config.packageInfo;
        if (config.appRoot === "" || path.isAbsolute(config.appRoot)) {
            this._packageInfo.packageJsonFullPath = config.appRoot;
        }
        else {
            throw new Error(("Invalid app root \"" + config.appRoot + "\". ") +
                "You must provide an absolute path or an empty string");
        }
        this._exeName = config.exeName;
        this.emitter = new events_1.EventEmitter();
        this.channels = [];
    }
    ErrorReporter.prototype.addReportingChannel = function (channel) {
        this.channels.push(channel);
        channel.registerListeners(this);
    };
    ErrorReporter.prototype.removeReportingChannel = function (channel) {
        var index = this.channels.indexOf(channel);
        if (index !== -1) {
            this.channels.splice(index, 1);
        }
    };
    Object.defineProperty(ErrorReporter.prototype, "appName", {
        get: function () {
            return this._packageInfo.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ErrorReporter.prototype, "appVersion", {
        get: function () {
            return this._packageInfo.version;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ErrorReporter.prototype, "appRoot", {
        get: function () {
            return this._packageInfo.packageJsonFullPath;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ErrorReporter.prototype, "branch", {
        get: function () {
            return this._packageInfo.branch;
        },
        enumerable: true,
        configurable: true
    });
    ErrorReporter.prototype.reportError = function (err, errorType) {
        var _this = this;
        this.emitReportingStarted();
        var stack;
        try {
            stack = new advanced_1.ErrorInformation({ rawError: err,
                packageInfo: this._packageInfo,
                errorType: errorType,
                exeName: this._exeName,
                errorReporter: this });
        }
        catch (e) {
            try {
                this.emitInternalError(e, err, "");
            }
            catch (e1) {
            }
            if (!stack) {
                return Promise.resolve({});
            }
        }
        var reportPromises = [];
        var rejectionFunctions = [];
        var timeoutLimits = [];
        this.channels.forEach(function (channel) {
            var prom;
            try {
                prom = channel.report(stack);
            }
            catch (e) {
                prom = Promise.reject(e);
            }
            var timeoutPromise = new Promise(function (resolve, reject) {
                rejectionFunctions.push(reject);
                timeoutLimits.push(channel.timeout);
            });
            var compositeProm = Promise.race([prom, timeoutPromise]);
            reportPromises.push(compositeProm);
        });
        for (var i = 0; i < rejectionFunctions.length; i++) {
            if (timeoutLimits[i] >= 0) {
                setTimeout(rejectionFunctions[i], timeoutLimits[i], "timed out after " + timeoutLimits[i] + " ms");
            }
        }
        return try_all_1.tryAll(reportPromises)
            .then(function (results) {
            _this.reportInternalFailures(results, _this.channels);
            _this.emitReportingFinished(results);
            return results;
        })
            .catch(function (reason) {
            return reason;
        });
    };
    ;
    ErrorReporter.prototype.reportInternalFailures = function (results, channels) {
        for (var i = 0; i < channels.length; i++) {
            if (channels[i].reportOnFailure && !results.resolved[i]) {
                this.emitInternalError(results.failReasons[i], null, null);
            }
        }
    };
    ErrorReporter.prototype.onInternalError = function (callback) {
        this.emitter.on(INTERNAL_ERROR, callback);
    };
    ErrorReporter.prototype.emitInternalError = function (internalError, errorBeingProcessed, problemString) {
        if (this.emitter.listenerCount(INTERNAL_ERROR) > 0) {
            var proc = new advanced_1.ErrorInformation({ rawError: internalError });
            var stack = void 0;
            try {
                stack = proc.getVerboseStack();
            }
            catch (e) {
                stack = "UNKNOWN\tUNKNOWN";
            }
            var info = {
                props: {
                    InternalErrorStack: stack,
                    InternalErrorType: proc.errorName
                },
                PIIProps: {
                    InternalErrorMessage: proc.errorMessage,
                    RawInternalError: internalError,
                    OriginalError: errorBeingProcessed,
                    ProblemString: problemString
                }
            };
            this.emitter.emit(INTERNAL_ERROR, info);
        }
    };
    ErrorReporter.prototype.onReportingStarted = function (callback) {
        this.emitter.on(ERROR_REPORTING_STARTED, callback);
    };
    ErrorReporter.prototype.emitReportingStarted = function () {
        return this.emitter.emit(ERROR_REPORTING_STARTED);
    };
    ErrorReporter.prototype.onReportingFinished = function (callback) {
        this.emitter.on(ERROR_REPORTING_FINISHED, callback);
    };
    ErrorReporter.prototype.emitReportingFinished = function (results) {
        return this.emitter.emit(ERROR_REPORTING_FINISHED, results);
    };
    return ErrorReporter;
}());
exports.ErrorReporter = ErrorReporter;
