/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
"use strict";
var url = require("url");
var crypto = require("crypto");
var fileCache = require("./internal/file-cache");
var https = require("./internal/node-https-promise");
var timers = require("./internal/node-timers-promise");
var defaultTtl = 30 * 60 * 1000;
/**
 * The file downloader keeps an ETAG as an internal state.
 */
function fileDownloader(urlString, ttl) {
    ttl = ttl || defaultTtl;
    var urlStruct = url.parse(urlString);
    // https://en.wikipedia.org/wiki/URL_normalization
    var normalizedUrl = url.format(urlStruct);
    var key = crypto.createHash("sha256").update(normalizedUrl).digest("hex");
    var etag;
    return function () {
        // it should be the first statement because we don't want to have a moving target.
        var startDate = Date.now();
        var expectedDate = startDate - ttl;
        var httpsDownload = function (fileEtag) { return https
            .request(urlStruct, fileEtag)
            .then(function (response) {
            var saveFile = function (buffer, responseEtag) {
                return new fileCache.RemoteFile(Date.now(), responseEtag, buffer)
                    .saveFileAndClean(key);
            };
            switch (response.getStatusCode()) {
                case https.StatusCode.OK:
                    return saveFile(response.getBuffer(), response.getHeaders().etag);
                case https.StatusCode.NotModified:
                    return fileCache
                        .getCachedFile(key)
                        .then(function (newFileResult) { return saveFile(newFileResult.getBuffer(), fileEtag); });
                // can't download a file.
                default:
                    return Promise.reject("HTTPS error");
            }
        })
            .catch(function () { return fileCache.getCachedFile(key, etag); }); };
        return fileCache
            .getCachedFile(key, etag, expectedDate)
            .then(function (fileResult) { return fileResult.getDate() >= expectedDate
            ? fileResult
            : httpsDownload(fileResult.getETag()); }, function () { return httpsDownload(); })
            .then(function (fileResult) {
            var fileEtag = fileResult.getETag();
            if (etag && etag === fileEtag) {
                return Promise.reject("no changes");
            }
            etag = fileEtag;
            return fileResult.getBuffer();
        });
    };
}
/**
 * @param urlString is a file URL.
 * @param ttl is a TTL of the file in cache.
 * @param etag is a ETag which is already loaded.
 *
 * @return a buffer promise. the promise can be rejected if the file wasn't downloaded.
 */
function downloadFile(urlString, ttl) {
    return fileDownloader(urlString, ttl)();
}
exports.downloadFile = downloadFile;
/**
 * Subscribe on a file update.
 *
 * @param onFileUpdate will be called at least once. The buffer will be null if the specified file can't be downloaded.
 *                     All errorrs and rejected promises from the function will be ignored.
 */
function subscribeOnFileUpdate(urlString, onFileUpdate, ttl) {
    ttl = ttl || defaultTtl;
    // we use the same TTL for the file downloader because the file cache can be updated by
    // another program.
    var downloader = fileDownloader(urlString, ttl);
    var counter = 0;
    return timers.timeout(function () {
        ++counter;
        return downloader()
            .then(onFileUpdate, function () { return counter <= 1 ? onFileUpdate(null) : null; })
            .catch(function () { return null; });
    }, ttl, true);
}
exports.subscribeOnFileUpdate = subscribeOnFileUpdate;
