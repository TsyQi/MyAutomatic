/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
"use strict";
var os = require("os");
var fsp = require("node-fs-promise");
var path = require("path");
var str = require("string");
var Paths = (function () {
    function Paths(key) {
        this._cache = path.join(os.tmpdir(), "remote-file-71752ccfe2464e99");
        this._key = path.join(this._cache, key);
    }
    Paths.prototype.getCachePath = function () { return this._cache; };
    Paths.prototype.getKeyPath = function () { return this._key; };
    return Paths;
}());
var RemoteFile = (function () {
    function RemoteFile(date, etag, buffer) {
        this._date = date;
        this._etag = etag || "";
        this._buffer = buffer || null;
    }
    RemoteFile.prototype.getDate = function () { return this._date; };
    RemoteFile.prototype.getETag = function () { return this._etag; };
    RemoteFile.prototype.getBuffer = function () { return this._buffer; };
    RemoteFile.prototype.getFileName = function () {
        // 12 digits covers date until Aug 10889. It should be enough.
        return toHexString(this.getDate(), 12) + "-" + this.getETag();
    };
    RemoteFile.prototype.getFilePath = function (folder) {
        return path.join(folder, this.getFileName());
    };
    /**
     * The function should never return rejected promise.
     */
    RemoteFile.prototype.saveFileAndClean = function (key) {
        var _this = this;
        var paths = new Paths(key);
        var keyPath = paths.getKeyPath();
        var mkdir = function (path) { return fsp.mkdir(path).catch(function () { return null; }); };
        return mkdir(paths.getCachePath())
            .then(function () { return mkdir(keyPath); })
            .then(function () { return fsp.writeFile(_this.getFilePath(keyPath), _this.getBuffer()); })
            .then(function () { return fsp.readdir(keyPath); })
            .then(function (dir) { return dir
            .sort()
            .filter(function (_, index, array) { return index + 2 < array.length; })
            .reduce(function (result, fileName) { return fsp.unlink(path.join(keyPath, fileName))
            .catch(function () { return null; })
            .then(function () { return result; }); }, Promise.resolve()); })
            .then(function () { return _this; }, function () { return _this; });
    };
    return RemoteFile;
}());
exports.RemoteFile = RemoteFile;
/**
 * Returns the recent remote file object or null if no such objects.
 */
function getLatest(array) {
    return array.reduce(function (c, p) { return p && (!c || c.getDate() < p.getDate()) ? p : c; }, null);
}
exports.getLatest = getLatest;
function toHexString(n, size) {
    return str(n.toString(16)).padLeft(size, "0").toString();
}
exports.toHexString = toHexString;
function parseFileName(fileName) {
    var split = fileName.split("-");
    var date = parseInt(split[0], 16);
    var etag = split[1];
    if (isNaN(date) || etag === undefined) {
        return null;
    }
    var result = new RemoteFile(date, etag);
    // check if the file was created by this program.
    return result.getFileName() === fileName ? result : null;
}
exports.parseFileName = parseFileName;
function getRemoteFileList(fileList) {
    return fileList.map(parseFileName).filter(function (x) { return !!x; });
}
exports.getRemoteFileList = getRemoteFileList;
/**
 * Get a file from file cache for the given key.
 *
 * @param key is a key for the file cache dictionary.
 * @param etag is a ETag of a file which is already loaded into memory.
 * @param expectedDate is a date which expected for the file.
 *
 * @return Promise.resolve<RemoteFile> where RemoteFile is not null, or Promise.reject<any> if a file
 *         with the given key doesn't exist. getBuffer() is null if the file doesn't satisfy expectedDate
 *         condition.
 */
function getCachedFile(key, etag, expectedDate) {
    var folder = new Paths(key).getKeyPath();
    // try disk cache
    return fsp
        .readdir(folder)
        .then(function (fileList) {
        var result = getLatest(getRemoteFileList(fileList));
        return !result ? Promise.reject("no file")
            : (expectedDate && result.getDate() < expectedDate) || (etag && result.getETag() === etag) ? result
                : fsp
                    .readFile(result.getFilePath(folder))
                    .then(function (buffer) { return new RemoteFile(result.getDate(), result.getETag(), buffer); });
    });
}
exports.getCachedFile = getCachedFile;
