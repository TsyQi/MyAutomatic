/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
"use strict";
var dispose = require("lazy-disposable");
/**
 * @note the DeferredDisposable.using() function will return rejected promise if the callback returns a
 *       rejected promise or throw an exception.
 */
function interval(callback, ms) {
    return dispose.deferredDisposable(
    // init()
    function () {
        var state = {
            promise: Promise.resolve(),
            timer: null,
        };
        state.timer = setInterval(
        // chain promises because some of them may still running.
        function () { return state.promise = state.promise.then(callback); }, ms);
        return state;
    }, 
    // dispose()
    function (state) {
        clearInterval(state.timer);
        return state.promise;
    })
        .map(function (state) { return null; });
}
exports.interval = interval;
function immediate(value) {
    return new Promise(function (resolve) { return setImmediate(function () { return resolve(value); }); });
}
exports.immediate = immediate;
function sleep(ms) {
    return new Promise(function (resolve) { return setTimeout(resolve, ms); });
}
exports.sleep = sleep;
/**
 * Continuously sets timeouts. The callback function should return a rejected promise in order to stop setting timeouts.
 *
 * @note the DeferredDisposable.using() function will return a rejected promise if the callback returns a
 *       rejected promise or throws an exception.
 */
function timeout(callback, ms, callImmediate) {
    return dispose.deferredDisposable(
    // init()
    function () {
        var state = {
            ms: callImmediate ? 0 : ms,
            disposed: false,
            promise: Promise.resolve(),
            timer: null,
        };
        var setNewTimeout = function () {
            if (!state.disposed) {
                state.timer = setTimeout(
                // don't need to chain promises because setNewTimeout is called only when the
                // state.promise is resolved.
                function () { return state.promise = Promise.resolve()
                    .then(callback)
                    .then(setNewTimeout); }, state.ms);
                state.ms = ms;
            }
        };
        // initialize the first timeout.
        setNewTimeout();
        return state;
    }, 
    // dispose()
    function (state) {
        state.disposed = true;
        clearTimeout(state.timer);
        return state.promise;
    })
        .map(function (state) { return null; });
}
exports.timeout = timeout;
