/*!---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
"use strict";
var _1 = require("./");
var path_1 = require("path");
var defaultpath = require("path");
var fs = require("fs");
var NODE_MODULES_DIRNAME = "node_modules";
var PACKAGE_JSON_NAME = "package.json";
var VALID_NON_CODE_LOCATIONS = ["native", "NonError", "unknown"];
var StackProcessor = (function () {
    function StackProcessor(options) {
        this.doFileIO = true;
        this.appRoot = options.appRoot;
        this._errorReporter = options.errorReporter;
        this._packageInfo = options.packageInfo;
        switch (options.mode) {
            case _1.pathMode.defaultMode:
                this.path = defaultpath;
                break;
            case _1.pathMode.posix:
                this.path = path_1.posix;
                break;
            case _1.pathMode.windows:
                this.path = path_1.win32;
                break;
            default:
                this.path = defaultpath;
        }
    }
    StackProcessor.prototype.parseFirstLine = function (firstLine) {
        var firstLineRX = /(^.+?\b)(?:: )?(?:(.+?\b): )?(.*)/;
        var ERROR_SS = 1;
        var SYSTEM_ERROR_SS = 2;
        var MESSAGE_SS = 3;
        var matches = firstLine.match(firstLineRX);
        var type;
        if (matches[ERROR_SS] === "Error" && matches[SYSTEM_ERROR_SS]) {
            type = matches[SYSTEM_ERROR_SS];
        }
        else {
            type = matches[ERROR_SS];
        }
        var message = matches[MESSAGE_SS];
        return { ErrorType: type, ErrorMessage: message, Stack: [] };
    };
    StackProcessor.prototype.parseStackLine = function (inputLine, getPackageInfo) {
        if (getPackageInfo === void 0) { getPackageInfo = false; }
        var isEval = false;
        if (inputLine.includes("eval at")) {
            isEval = true;
            inputLine = this.cleanEvalFrames(inputLine);
        }
        inputLine = _1.replaceAll(inputLine, "(anonymous function)", "(anonymousfunction)");
        inputLine = _1.replaceAll(inputLine, "unknown location", "unknown");
        var mainRX = /\s*at (new )?(.+?)(?: \[as ([^ ]+?)\])?(?: \((.*)\))?$/;
        var newSS = 1;
        var functionNameSS = 2;
        var asMethodSS = 3;
        var locationSS = 4;
        var functionName;
        var location;
        var atNew = false;
        var asString = "";
        var mainMatches = inputLine.match(mainRX);
        if (!mainMatches) {
            var e = new Error("unrecognized stack trace format: " + inputLine);
            if (this._errorReporter) {
                this._errorReporter.emitInternalError(e, null, inputLine);
            }
            var temp = {
                RelativePath: "UNSUPPORTED",
                Package: { name: "UNSUPPORTED" },
                line: -1,
                column: -1,
                extra: { failedToParse: true } };
            return temp;
        }
        if (mainMatches[newSS]) {
            atNew = true;
        }
        if (mainMatches[asMethodSS]) {
            asString = mainMatches[asMethodSS];
        }
        if (mainMatches[locationSS]) {
            location = mainMatches[locationSS];
            functionName = mainMatches[functionNameSS];
        }
        else {
            location = mainMatches[functionNameSS];
            functionName = "";
        }
        var result = this.parseCodeLocation(location);
        result.FunctionName = functionName;
        var stripped = this.getPackageInfo(result.RelativePath);
        result.RelativePath = stripped.strippedPath;
        if (getPackageInfo && stripped.package) {
            result.Package = stripped.package;
        }
        if (atNew || asString || isEval) {
            if (atNew) {
                result.FunctionName += ".constructor";
            }
            if (asString) {
                result.FunctionName += "[" + asString + "]";
            }
            result.extra = { isNew: atNew, hasAs: asString, isEval: isEval, failedToParse: false, rawString: "" };
        }
        return result;
    };
    StackProcessor.prototype.cleanEvalFrames = function (input) {
        var evalRX = /\eval at .+\), /;
        return input.replace(evalRX, "");
    };
    StackProcessor.prototype.parseCodeLocation = function (input) {
        var i = VALID_NON_CODE_LOCATIONS.length;
        var element;
        while (i--) {
            element = VALID_NON_CODE_LOCATIONS[i];
            if (element === input) {
                return { RelativePath: input, line: -1, column: -1, FunctionName: "" };
            }
        }
        input = _1.replaceAll(input, "file:///", "");
        input = _1.replaceAll(input, "%20", " ");
        var locationRX = /(?:(^.+):(\d+):(\d+))/;
        var PATH_SS = 1;
        var LINE_SS = 2;
        var COLUMN_SS = 3;
        var line;
        var column;
        var matches = input.match(locationRX);
        if (!matches) {
            var intError = new Error("unsupported location format");
            if (this._errorReporter) {
                this._errorReporter.emitInternalError(intError, null, input);
            }
            return { RelativePath: "UNSUPPORTED", line: -1, column: -1, FunctionName: "" };
        }
        else {
            line = parseInt(matches[LINE_SS], 10);
            column = parseInt(matches[COLUMN_SS], 10);
        }
        var path = this.path.normalize(matches[PATH_SS]);
        return { RelativePath: path, line: line, column: column, FunctionName: "" };
    };
    StackProcessor.prototype.getPackageInfo = function (filePath) {
        var i = VALID_NON_CODE_LOCATIONS.length;
        var element;
        while (i--) {
            element = VALID_NON_CODE_LOCATIONS[i];
            if (element === filePath) {
                return { package: { name: "UNKNOWN" }, strippedPath: filePath };
            }
        }
        if (!this.path.isAbsolute(filePath)) {
            return {
                package: { name: "node", version: process.version },
                strippedPath: filePath };
        }
        var relPath = this.path.relative(this.appRoot, filePath);
        var nodeModIndex = filePath.lastIndexOf(NODE_MODULES_DIRNAME);
        if (nodeModIndex !== -1) {
            var modRoot = filePath.substring(0, nodeModIndex + NODE_MODULES_DIRNAME.length + 1);
            var modPath = this.path.relative(modRoot, filePath);
            var sepIndex = modPath.indexOf(this.path.sep);
            if (sepIndex !== -1) {
                var modName = modPath.substring(0, sepIndex);
                relPath = modPath.substring(sepIndex + 1);
                var pkg = { name: modName };
                if (this.doFileIO) {
                    try {
                        var fullPath = this.path.join(modRoot, modName, PACKAGE_JSON_NAME);
                        var pkgjs = JSON.parse(fs.readFileSync(fullPath, "utf8"));
                        pkg.packageJsonFullPath = fullPath;
                        if (pkgjs.name) {
                            pkg.name = pkgjs.name;
                        }
                        if (pkgjs.version) {
                            pkg.version = pkgjs.version;
                        }
                    }
                    catch (e) {
                    }
                }
                relPath = _1.convertPathToPosix(relPath);
                return { package: pkg, strippedPath: relPath };
            }
            if (this._errorReporter) {
                this._errorReporter.emitInternalError(new Error("javascript file in unexpected location"), null, filePath);
            }
            filePath = this.path.basename(filePath);
            return { package: { name: "UNKNOWN" }, strippedPath: filePath };
        }
        if (filePath.includes(".asar")) {
            var index = filePath.lastIndexOf(".asar") + ".asar".length;
            var asarName = this.path.basename(filePath.substring(0, index));
            var relativePath = _1.convertPathToPosix(filePath.substring(index + 1));
            relPath = _1.convertPathToPosix(relPath);
            return { package: { name: asarName }, strippedPath: relativePath };
        }
        if (relPath === filePath || relPath.startsWith("..") || this.appRoot === "") {
            filePath = this.path.basename(filePath);
            return { package: { name: "UNKNOWN" }, strippedPath: filePath };
        }
        relPath = _1.convertPathToPosix(relPath);
        return { package: this._packageInfo, strippedPath: relPath };
    };
    return StackProcessor;
}());
exports.StackProcessor = StackProcessor;
function removeUserName(input) {
    var userNameRX = /[a-z]:\\Users\\([^\\]+)/i;
    var match = input.match(userNameRX);
    if (match) {
        input = _1.replaceAll(input, match[1], "USERNAME");
    }
    return input;
}
exports.removeUserName = removeUserName;
function structuredToSemiWatson(input) {
    var _this = this;
    var WLB = _1.WATSON_LINE_BREAK;
    var result = "";
    input.Stack.forEach(function (frame) {
        result += (result ? WLB : "") + _this.frameToString(frame);
    });
    return result;
}
exports.structuredToSemiWatson = structuredToSemiWatson;
function structuredToStandard(input) {
    var stack = "";
    input.Stack.forEach(function (frame) {
        if (frame.FunctionName) {
            stack += (stack ? "\n" : "") + ("" + ((frame.extra && frame.extra.isEval) ? "eval " : ""))
                + ("at " + frame.FunctionName + " ") +
                ("(" + frame.RelativePath);
            if (frame.line !== -1 && frame.column !== -1) {
                stack += ":" + frame.line + ":" + frame.column;
            }
            stack += ")";
        }
        else {
            stack += (stack ? "\n" : "") + (((frame.extra && frame.extra.isEval) ? "eval " : "") + "at ") +
                ("" + frame.RelativePath);
            if (frame.line !== -1 && frame.column !== -1) {
                stack += ":" + frame.line + ":" + frame.column;
            }
        }
    });
    return stack;
}
exports.structuredToStandard = structuredToStandard;
function frameToString(frame) {
    if (!frame) {
        return "UNSUPPORTED\tUNSUPPORTED";
    }
    var packageString = frame.Package.name;
    if (!packageString) {
        packageString = "UNKNOWN";
    }
    if (frame.Package.version) {
        packageString += "@" + frame.Package.version;
    }
    var fileInfo = frame.RelativePath;
    if (!fileInfo) {
        fileInfo = "UNKNOWN";
    }
    if (frame.line !== -1 && frame.column !== -1) {
        fileInfo += ":" + frame.line + ":" + frame.column;
    }
    var result = packageString + "\t" + fileInfo;
    if (frame.FunctionName) {
        result += "\t" + frame.FunctionName;
    }
    return result;
}
exports.frameToString = frameToString;
