/*!---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var error_reporter_base_1 = require("./error-reporter-base");
var advanced_1 = require("./advanced");
var try_all_1 = require("./try-all");
(function (State) {
    State[State["ready"] = 0] = "ready";
    State[State["reporting"] = 1] = "reporting";
    State[State["finishing"] = 2] = "finishing";
})(exports.State || (exports.State = {}));
var State = exports.State;
var ERROR_REPORTING_ASYNC_FAILURE = "ErrorReportAsyncFailure";
var USER_CALLBACK_UNCAUGHT_EXCEPTION = "userCallbackUncaught";
exports.UNCAUGHT_EXCEPTION_EVENT_NAME = "uncaughtException";
exports.UNHANDLED_PROMISE_REJECTION_EVENT_NAME = "unhandledRejection";
function RemoveAllNodeErrorHandlers() {
    process.removeAllListeners(exports.UNCAUGHT_EXCEPTION_EVENT_NAME);
    process.removeAllListeners(exports.UNHANDLED_PROMISE_REJECTION_EVENT_NAME);
}
exports.RemoveAllNodeErrorHandlers = RemoveAllNodeErrorHandlers;
var ErrorHandlerNode = (function (_super) {
    __extends(ErrorHandlerNode, _super);
    function ErrorHandlerNode(options) {
        var _this = this;
        _super.call(this, { appRoot: options.appRoot, packageInfo: options.packageInfo, exeName: options.exeName });
        this.finalCallback = options.finalCallback;
        this.currentState = State.ready;
        advanced_1.setStackTraceLimit(Infinity);
        this.uncaughtExceptionHandler = function (err) { return _this.handleUncaughtMain(err, error_reporter_base_1.ErrorType.Exception); };
        this.unhandledRejectionHandler = function (err) {
            _this.handleUncaughtMain(err, error_reporter_base_1.ErrorType.Rejection);
        };
        process.on(exports.UNCAUGHT_EXCEPTION_EVENT_NAME, this.uncaughtExceptionHandler);
        process.on(exports.UNHANDLED_PROMISE_REJECTION_EVENT_NAME, this.unhandledRejectionHandler);
    }
    ErrorHandlerNode.prototype.removeThisHandler = function () {
        this.removeOwnHandlers();
    };
    ErrorHandlerNode.prototype.removeOwnHandlers = function () {
        process.removeListener(exports.UNCAUGHT_EXCEPTION_EVENT_NAME, this.uncaughtExceptionHandler);
        process.removeListener(exports.UNHANDLED_PROMISE_REJECTION_EVENT_NAME, this.unhandledRejectionHandler);
    };
    ErrorHandlerNode.prototype.handleUncaughtMain = function (err, errorType) {
        var _this = this;
        if (this.currentState === State.ready) {
            this.currentState = State.reporting;
        }
        else if (this.currentState === State.reporting) {
            try {
                this.emitAsyncFailure(err);
            }
            catch (e) {
            }
            return;
        }
        else if (this.currentState === State.finishing) {
            this.finalExit();
        }
        var e = advanced_1.coerceToError(err, errorType);
        this.reportError(e, error_reporter_base_1.ErrorType[errorType]).then(function () { _this.finishHandling(e, errorType); });
    };
    ErrorHandlerNode.prototype.finishHandling = function (err, errorType) {
        this.currentState = State.finishing;
        try {
            if (this.finalCallback && this.finalCallback(err)) {
                this.currentState = State.ready;
                return;
            }
        }
        catch (e) {
            try {
                this.emitUserCallbackUncaughtException(e);
            }
            catch (e1) {
            }
        }
        try {
            if (this.crashOnErrorTypes && this.crashOnErrorTypes.indexOf(errorType) === -1) {
                this.currentState = State.ready;
                return;
            }
            this.emitAboutToExit().then(this.finalExit, this.finalExit);
            setTimeout(this.finalExit, 500);
        }
        catch (e2) {
            this.finalExit();
        }
    };
    ErrorHandlerNode.prototype.finalExit = function () {
        if (process.platform === "win32") {
            process.abort();
        }
        process.exit(1);
    };
    ErrorHandlerNode.prototype.onAboutToExit = function (callback) {
        if (this.aboutToExitPromises === undefined) {
            this.aboutToExitPromises = [];
        }
        this.aboutToExitPromises.push(callback);
    };
    ErrorHandlerNode.prototype.emitAboutToExit = function () {
        if (this.aboutToExitPromises) {
            var promises_1 = [];
            this.aboutToExitPromises.forEach(function (element) {
                try {
                    promises_1.push(element());
                }
                catch (e) {
                }
            });
            return try_all_1.tryAll(promises_1);
        }
        return Promise.resolve();
    };
    ErrorHandlerNode.prototype.onAsyncFailure = function (callback) {
        this.emitter.on(ERROR_REPORTING_ASYNC_FAILURE, callback);
    };
    ErrorHandlerNode.prototype.emitAsyncFailure = function (asyncError) {
        return this.emitter.emit(ERROR_REPORTING_ASYNC_FAILURE, asyncError);
    };
    ErrorHandlerNode.prototype.onUserCallbackUncaughtException = function (callback) {
        this.emitter.on(USER_CALLBACK_UNCAUGHT_EXCEPTION, callback);
    };
    ErrorHandlerNode.prototype.emitUserCallbackUncaughtException = function (uncaughtException) {
        this.emitter.emit(USER_CALLBACK_UNCAUGHT_EXCEPTION, uncaughtException);
    };
    return ErrorHandlerNode;
}(error_reporter_base_1.ErrorReporter));
exports.ErrorHandlerNode = ErrorHandlerNode;
