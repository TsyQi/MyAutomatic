# Getting Started

In order to consume VS Telemetry API in a standalone Node.js application you need to install the
[vs-telemetry]((https://devdiv.visualstudio.com/NodeRepos/_apps/hub/ms.feed.feed-hub?feedName=NodeRepos&protocolType=Npm&packageName=vs-telemetry)
package from the
[VSTS NPM NodeRepos feed](https://devdiv.visualstudio.com/NodeRepos/_apps/hub/ms.feed.feed-hub?feedName=NodeRepos).
The packase will also install other packages, including
[vs-telemetry-api](https://devdiv.visualstudio.com/NodeRepos/_apps/hub/ms.feed.feed-hub?feedName=NodeRepos&protocolType=Npm&packageName=vs-telemetry-api)
which contains public API for VS Telemetry.

## Install vs-telemetry Packages

Follow the [VSTS NPM instruction](https://vstspkgnpm.blob.core.windows.net/vstspkgnpm/registry.html) to connect to
[NodeRepos feed](https://devdiv.visualstudio.com/NodeRepos/_apps/hub/ms.feed.feed-hub?feedName=NodeRepos).

Create the `.npmrc` file in your project with this content.

```
registry=https://devdiv.pkgs.visualstudio.com/DefaultCollection/_packaging/NodeRepos/npm/registry
always-auth=true
```

Run this command

```
npm install vs-telemetry --save
```

## Create Telemetry Session, send an event and close the session

Most of telemetry operations are asynchronous and return ES6 promises.

```typescript
import { TelemetryService } from "vs-telemetry";

// get default telemetry session.
const telemetry = TelemetryService.getDefaultSession();

// send an event.
telemetry.postEvent("MyCoolEvent");

// close/dispose the session.
telemetry.dispose();
```

See also
- [index.ts](index.ts) for API.
- [vs-telemetry-scenario](https://devdiv.visualstudio.com/DefaultCollection/NodeRepos/NodeRepos%20Team/_git/vs-telemetry-scenario?path=%2Findex.ts&version=GBmaster&_a=contents) for more examples.

# API on Telemetry object

## Check Whether Telemetry Session is OptedIn

```typescript
isOptedIn(): Promise<boolean>;
```
Example:
```typescript
telemetry.isOptedIn().then(isOptedIn => {
    if (isOptedIn) console.log("Session is opted in");
});
```

## Check Whether Telemetry is Enabled
In case telemetry is disabled no telemetry events are sent at all.
```typescript
isEnabled(): Promise<boolean>;
```
Example:
```typescript
telemetry.isEnabled().then(isEnabled => {
    if (!isEnabled) console.log("Session is completely disabled");
});
```

## Check Whether Current User is Microsoft Internal
```typescript
isMicrosoftInternal(): Promise<boolean>;
```
Example:
```typescript
telemetry.isMicrosoftInternal().then(isMicrosoftInternal => {
    if (isMicrosoftInternal) console.log("User is Microsoft internal");
});
```

## Check Whether Current Session can Collect PII
In the case when session can collect PII it is possible to log telemetry like:
absolute paths, user aliases, domain name and so on without hashing.
```typescript
canCollectPrivateInformation(): Promise<boolean>;
```
Example:
```typescript
telemetry.canCollectPrivateInformation().then(canCollectPII => {
    if (canCollectPII) console.log("Current session can collect PII");
});
```

## Obtain Current User Alias
Get user alias as it is used by the telemetry.
In the case when it is impossible to collect PII user alias is just empty string.
```typescript
userAlias(): Promise<string>;
```
Example:
```typescript
telemetry.userAlias().then(alias => {
    console.log("User alias is: " + alias);
});
```

## Set OptedIn Status
By default OptedIn status is set to false, that's mean only very limited events are allowed to pass through.
It is strongly recommended for the application to set OptedIn status before calling start() on Telemetry object.
```typescript
setIsOptedIn(status: boolean): void;
```
Example:
```typescript
telemetry.setIsOptedIn(true);
```

## Get Session Identifier
Session identifier is uniquely identifies each session.
```typescript
sessionId(): Promise<string>;
```
Example:
```typescript
telemetry.sessionId().then(sessionId => {
    console.log("Session id is: " + sessionId);
});
```

## Get User Id
User Id is unique per pair user/machine.
```typescript
userId(): Promise<string>;
```
Example:
```typescript
telemetry.userId().then(userId => {
    console.log("User ID is: " + userId);
});
```

## Get Machine Id
Machine Id is unique per machine.
```typescript
machineId(): Promise<string>;
```
Example:
```typescript
telemetry.machineId().then(machineId => {
    console.log("Machine ID is: " + machineId);
});
```

## Start Session
In order to let events are sent over the wire you need to start session.
Calling start method automatically creates transport channels and flush internal events buffer.
```typescript
start(): void;
```
Example:
```typescript
telemetry.start();
});
```

## Post Events
Before post event you need to create event object, add parameters and call postEvent method.
If you don't need to specify custom properties you can just call postEvent with event name.
```typescript
postEvent(event: string | ServiceApi.Event): void;
```
Example:
```typescript
import { Event as TelemetryEvent } from "vs-telemetry-api";

// event without properties
telemetry.postEvent("VS/Core/SampleEventWithoutProperties");

// event with custom properties
let ev = new TelemetryEvent("VS/Core/SampleEvent");
ev.properties["VS.Core.SampleEvent.Frequency"] = 42;
ev.properties["VS.Core.SampleEvent.Type"] = "Glide";
telemetry.postEvent(ev);
});
```

## Post UserTask Events
UserTaskEvent is used to track a user invoked action (more details at [Data Model](http://vstelwiki/wiki/How_to_write_product_Instrumentation_with_Data_Model_Extensions)).
Depending on whether you'd like to track both start and end points of a User Task, there're two ways to post UserTaskEvents.

### 1. Post Atomic UserTask Events
Generally you post the event when UserTask completes. You can either use postUserTask method with a long parameter list
OR create UserTask event object and then call postEvent method. Both ways support custom properties.
```typescript
postUserTask(
    eventName: string,
    result: TelemetryResult,
    resultSummary?: string,
    eventProperties?: StringMap,
    severity?: TelemetrySeverity
): void;
```
Example:
```typescript
import { UserTaskEvent } from "vs-telemetry-api";

// case 1: one line to post user task
telemetry.postUserTask("VS/Core/do-foo-usertask", TelemetryResult.Success);

// case 2: create UserTaskEvent and then post
let ev = new UserTaskEvent("VS/Core/do-foo-usertask", TelemetryResult.Success);
ev.properties["VS.Core.SampleEvent.Frequency"] = 42;
ev.properties["VS.Core.SampleEvent.Type"] = "Glide";
telemetry.postEvent(ev);
```

### 2. Post Scoped UserTask Events
It is used to track both start and end points of a UserTask by posting one event for each point.
```typescript
startUserTask(
    eventName: string,
    startEventProperties?: StringMap,
    severity?: TelemetrySeverity
): TelemetryScope<UserTaskEvent>;
```
Example:
```typescript
import { TelemetryScope, UserTaskEvent } from "vs-telemetry-api";

// start the UserTask. (Start event is posted)
let userTaskScope = telemetry.startUserTask("VS/Core/do-foo-usertask");

// Product is handling the User Task.
// I can add custom properties while user task is running
userTaskScope.EndEvent.properties["VS.Core.SampleEvent.Type"] = "Glide";

// end the UserTask. (End event is posted)
userTaskScope.End(TelemetryResult.Success);
```

## Post Operation Events
OperationEvent is used to track a non-user invoked action (more details at [Data Model](http://vstelwiki/wiki/How_to_write_product_Instrumentation_with_Data_Model_Extensions)).
A common pattern is that a UserTask consists multiple operations running under the hood.

Operation APIs are almost identical to UserTask APIs. Depending on whether you'd like to track both start and end points of an Operation, there're two ways to post OperationEvents.

### 1. Post Atomic Operation Events
Generally you post the event when Operation completes. You can either use postOperation method with a long parameter list
OR create Operation event object and then call postEvent method. Both ways support custom properties.
```typescript
postOperation(
    eventName: string,
    result: TelemetryResult,
    resultSummary?: string,
    eventProperties?: StringMap,
    severity?: TelemetrySeverity
): void;
```
Example:
```typescript
import { OperationEvent } from "vs-telemetry-api";

// case 1: one line to post Operation
telemetry.postOperation("VS/Core/do-foo-operation", TelemetryResult.Success);

// case 2: create OperationEvent and then post
let ev = new OperationEvent("VS/Core/do-foo-operation", TelemetryResult.Success);
ev.properties["VS.Core.SampleEvent.Frequency"] = 42;
ev.properties["VS.Core.SampleEvent.Type"] = "Glide";
telemetry.postEvent(ev);
```

### 2. Post Scoped Operation Events
It is used to track both start and end points of an Operation by posting one event for each point.
```typescript
startOperation(
    eventName: string,
    startEventProperties?: StringMap,
    severity?: TelemetrySeverity
): TelemetryScope<OperationEvent>;
```
Example:
```typescript
import { TelemetryScope, OperationEvent } from "vs-telemetry-api";

// start the Operation. (Start event is posted)
let operationScope = telemetry.startOperation("VS/Core/do-foo-operation");

// Product is handling the Operationk.
// I can add custom properties while Operation is running
operationScope.EndEvent.properties["VS.Core.SampleEvent.Type"] = "Glide";

// end the Operation. (End event is posted)
operationScope.End(TelemetryResult.Success);
```

## Post Fault Events
FaultEvent is used to track fault details when something goes wrong in product (more details at [Data Model](http://vstelwiki/wiki/How_to_write_product_Instrumentation_with_Data_Model_Extensions)).
You can either use postFault method with a long parameter list
OR create Fault event object and then call postEvent method. Both ways support custom properties.
```typescript
postFault(
    eventName: string,
    description: string,
    error?: Error,
    eventProperties?: StringMap,
    severity?: TelemetrySeverity
): void;
```
Example:
```typescript
import { FaultEvent } from "vs-telemetry-api";

// case 1: one line to post Fault
telemetry.postFault("VS/Core/do-foo-operation-error", "Unexpected error happened when do foo operation", err);

// case 2: create Fault and then post
let ev = new FaultEvent("VS/Core/do-foo-operation-error", "Unexpected error happened when do foo operation", err);
ev.properties["VS.Core.FooOperation.FileSize"] = 10000;
ev.properties["VS.Core.FooOperation.ThreadCount"] = 99;
telemetry.postEvent(ev);
```

## Post Asset Events
AssetEvent is used for the target of UserTask or Operation (more details at [Data Model](http://vstelwiki/wiki/How_to_write_product_Instrumentation_with_Data_Model_Extensions)).
You can either use postAsset method with a long parameter list
OR create Asset event object and then call postEvent method. Both ways support custom properties.
```typescript
postAsset(
    eventName: string,
    assetId: string,
    assetEventVersion: number,
    eventProperties?: StringMap,
    severity?: TelemetrySeverity
): void;
```
Example:
```typescript
import { AssetEvent } from "vs-telemetry-api";

// case 1: one line to post Asset
telemetry.postAsset("VS/Core/myasset", "my-asset-id", 1);

// case 2: create Asset and then post
let ev = new AssetEvent("VS/Core/myasset", "my-asset-id", 1);
ev.properties["VS.Core.MyAsset.Type"] = "Foo";
ev.properties["VS.Core.MyAsset.Source"] = "Bar";
telemetry.postEvent(ev);
```

## Post Session Properties
You can post a session property that will be sent once for the session. These are batched and sent
in a context/postproperty event.
```typescript
postProperty(propertyName: string, propertyValue: string | number): void;
```
Example:
```typescript
telemetry.postProperty("my.posted.property", "propertyValue");
```

## Shared Session Properties
You can add a shared session property that will be attached to each event in the session.
These shared session properties are added to the default context.
```typescript
setSharedProperty(propertyName: string, propertyValue: string | number): void;
```
Example:
```typescript
telemetry.setSharedProperty("my.shared.property", "propertyValue");
```
You can get a shared session property that has been previously set. If it hasn't been set
the get will return null.
```typescript
getSharedProperty(propertyName: string): Promise<string | number>;
```
Example:
```typescript
telemetry.getSharedProperty("my.shared.property").then(value => {
    console.log(value); // Outputs "propertyValue"
});
```
You can remove a shared session property.
```typescript
removeSharedProperty(propertyName: string): void;
```
Example:
```typescript
telemetry.removedSharedProperty("my.shared.property");
```

## Serialize Session Settings
In order to clone session elsewhere you need to serialize current session to the string.
```typescript
serializeSettings(): Promise<string>;
```
Example:
```typescript
// serialize current session
let serializedSettings = telemetry.serializeSettings();

// elsewhere - create cloned session
serializedSettings.then(sessionString => {
	let clonedTelemetry = TelemetryService.cloneSession(sessionString);
    clonedTelemetry.start();
});
```

## Dispose
In order to flush all telemetry from the internal buffer to the backend before exit from the application you need to notify
telemetry session about closing. You can do that with dispose() method.
```typescript
dispose(): Promise<void>;
```
Example:
```typescript
// dispose session
telemetry.dispose().then(_ => {
	// now session is disposed and all pending events are sent
});
```

## Create Telemetry Context
A telemetry context represents a unit of work and allows you to attach shared properties to every event in that context or post a property associated with that context one time.
```typescript
let context = telemetry.createContext("MyContext")
```

Example:
```typescript
// add shared properties to the context
context.setSharedProperty("my.shared.context.property", "myValue");
// post a context property
context.postProperty("my.posted.context.property", "one-time-value");
```

# For Developers

## Build Process

1. Run `npm install`.
2. Run `npm test` to build and test the project.