/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
"use strict";
var vs_telemetry_api_1 = require("vs-telemetry-api");
var action_1 = require("./action");
var telemetry_manifest_1 = require("../telemetry-manifest/telemetry-manifest");
var crypto = require("crypto");
var PiiPropertyAction = (function () {
    function PiiPropertyAction(userInformation) {
        this._totalPiiProperties = 0;
        this._piiedProperties = {};
        this._totalSanitizedProperties = 0;
        this._sanitizedProperties = {};
        /**
         * Priority of the action
         * The less the more priority action.
         * Actions with more priority go before actions with lower priority
         */
        this.priority = action_1.ActionPriority.PiiPriority;
        this._userInformation = userInformation;
    }
    /**
     * Execute action on event.
     * @param context event processor context, which contains all necessary information to process the event
     * @return Event processed event or null, in the case when event is dropped (suppressed)
     */
    PiiPropertyAction.prototype.run = function (context) {
        var _this = this;
        var event = context.event;
        var toRemove = {};
        Object.keys(event.properties).forEach(function (propertyName) {
            var propertyValue = event.properties[propertyName];
            if (propertyValue instanceof vs_telemetry_api_1.PiiProperty) {
                toRemove[propertyName] = propertyValue;
            }
        });
        if (Object.keys(toRemove).length > 0) {
            return context.telemetrySession.canCollectPrivateInformation().then(function (canCollect) {
                var actionPromises = [];
                /* tslint:disable */
                for (var propertyName in toRemove) {
                    /* tslint:enable */
                    var piiProperty = toRemove[propertyName];
                    var propertyValue = piiProperty.value;
                    var piiAction = piiProperty.piiAction;
                    switch (piiAction) {
                        default:
                        case (vs_telemetry_api_1.PiiAction.Hashed):
                            _this._handleHashedAction(event, propertyName, propertyValue, canCollect);
                            break;
                        case (vs_telemetry_api_1.PiiAction.Sanitized):
                            var promise = _this._handleSanitizedAction(event, propertyName, propertyValue, canCollect);
                            actionPromises.push(promise);
                            break;
                    }
                }
                return Promise.all(actionPromises).then(function (_) { return null; });
            });
        }
        return Promise.resolve(null);
    };
    PiiPropertyAction.prototype.postDiagnosticInformation = function (session, oldManifest, newManifest) {
        if (this._totalPiiProperties === 0) {
            return;
        }
        var manifestVersion = PiiPropertyAction._unknownValue;
        if (oldManifest != null) {
            manifestVersion = oldManifest.version;
        }
        var statsEvent = new vs_telemetry_api_1.Event("VS/TelemetryApi/PiiProperties");
        statsEvent.properties["VS.TelemetryApi.DynamicTelemetry.Manifest.Version"] = manifestVersion;
        statsEvent.properties["VS.TelemetryApi.DynamicTelemetry.Hostname"] = telemetry_manifest_1.TelemetryManifest.hostname;
        statsEvent.properties["VS.TelemetryApi.PiiProperties.TotalCount"] = this._totalPiiProperties;
        statsEvent.properties["VS.TelemetryApi.PiiProperties.Properties"] =
            Object.keys(this._piiedProperties).join(",");
        statsEvent.properties["VS.TelemetryApi.SanitizedProperties.TotalCount"] = this._totalSanitizedProperties;
        statsEvent.properties["VS.TelemetryApi.SanitizedProperties.Properties"] =
            Object.keys(this._sanitizedProperties).join(",");
        session.postValidatedEvent(statsEvent);
    };
    PiiPropertyAction.prototype._handleHashedAction = function (event, propertyName, propertyValue, canCollect) {
        this._replacePropertyAndCheckToAddNotHashed(event, propertyName, propertyValue, this._hashPii(propertyValue.toString()), canCollect);
        this._piiedProperties[propertyName.toLowerCase()] = true;
        this._totalPiiProperties++;
    };
    PiiPropertyAction.prototype._handleSanitizedAction = function (event, propertyName, propertyValue, canCollect) {
        var _this = this;
        // No need to sanitize numbers
        if (typeof propertyValue === "string") {
            return this._replacePiiWithTokens(propertyValue.toString())
                .then(function (sanitizedValue) {
                _this._replacePropertyAndCheckToAddNotHashed(event, propertyName, propertyValue, sanitizedValue, canCollect);
                _this._sanitizedProperties[propertyName.toLowerCase()] = true;
                _this._totalSanitizedProperties++;
            });
        }
        else {
            event.properties[propertyName] = propertyValue;
            return Promise.resolve(null);
        }
    };
    PiiPropertyAction.prototype._replacePropertyAndCheckToAddNotHashed = function (event, propertyName, originalPropertyValue, modifiedPropertyValue, canCollect) {
        if (canCollect) {
            event.properties[propertyName + PiiPropertyAction._notHashedPropertySuffix] =
                originalPropertyValue;
        }
        event.properties[propertyName] = modifiedPropertyValue;
    };
    PiiPropertyAction.prototype._hashPii = function (value) {
        // Convert to uppercase to be consistent with .NET
        // Please note that Crypto instances are not reusable, so we have to call createHmac for each calling.
        // Source: https://github.com/nodejs/node-v0.x-archive/issues/1415
        return crypto.createHmac("sha256", PiiPropertyAction._key).update(value, "utf8").digest("hex").toUpperCase();
    };
    PiiPropertyAction.prototype._replacePiiWithTokens = function (value) {
        return this._userInformation.getUserName().then(function (userName) {
            if (userName != null && value != null) {
                return value.split(userName).join(PiiPropertyAction._userNamePlaceHolder);
            }
            return value;
        });
    };
    PiiPropertyAction._unknownValue = "Unknown";
    PiiPropertyAction._notHashedPropertySuffix = ".NotHashed";
    // Use same key from .NET
    PiiPropertyAction._key = "959069c9-9e93-4fa1-bf16-3f8120d7db0c";
    PiiPropertyAction._userNamePlaceHolder = "[USERNAME]";
    return PiiPropertyAction;
}());
exports.PiiPropertyAction = PiiPropertyAction;
