/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
"use strict";
var event_processor_context_1 = require("./dynamic-telemetry/event-processor-context");
var TelemetryEventProcessor = (function () {
    function TelemetryEventProcessor(router, telemetrySession, telemetryManifest, actions) {
        this._isDisposed = false;
        this._promiseComplete = Promise.resolve(null);
        this._router = router;
        this._telemetrySession = telemetrySession;
        this._telemetryManifest = telemetryManifest;
        this._builtinActions = actions.concat(this._router);
    }
    /**
     * Sets the current TelemetryManifest
     */
    TelemetryEventProcessor.prototype.setManifest = function (telemetryManifest) {
        this._postDiagnosticInformation(telemetryManifest);
        if (telemetryManifest != null) {
            this._telemetryManifest = telemetryManifest;
        }
    };
    /**
     * Gets the current TelemetryManifest
     */
    TelemetryEventProcessor.prototype.getManifest = function () {
        return this._telemetryManifest;
    };
    /**
     * Process incoming event. Apply dynamic telemetry, apply actions, send to router.
     * @param event Event to process
     */
    TelemetryEventProcessor.prototype.processEvent = function (event) {
        var _this = this;
        if (this._isDisposed) {
            return;
        }
        var eventProcessorContext = new event_processor_context_1.EventProcessorContext(event, this._telemetrySession, this._telemetryManifest);
        // get all actions for the event, join with builtin actions
        // sort action in appropriate order and run them in order
        // Router action goes as the last action
        this._telemetryManifest
            .getActionsForEvent(event)
            .concat(this._builtinActions)
            .sort(function (a, b) { return a.priority - b.priority; })
            .forEach(function (action) {
            _this._promiseComplete = _this._promiseComplete.then(function (_) { return action.run(eventProcessorContext); });
        });
    };
    /**
     * Posts diagnostic information if needed
     */
    TelemetryEventProcessor.prototype.postDiagnosticInformationIfNeeded = function () {
        return this._postDiagnosticInformation(null);
    };
    /**
     * Stop accepting events and wait for all operations completed.
     */
    TelemetryEventProcessor.prototype.dispose = function () {
        var _this = this;
        if (!this._isDisposed) {
            this._isDisposed = true;
            this._disposePromise = this._promiseComplete.then(function (_) { return _this._router.dispose(); });
        }
        return this._disposePromise;
    };
    TelemetryEventProcessor.prototype._postDiagnosticInformation = function (manifestToBeUpdated) {
        var _this = this;
        // post diagnostic information only after we have finished processing events that we have received so far
        return this._promiseComplete.then(function (_) {
            _this._builtinActions.forEach(function (action) {
                if (TelemetryEventProcessor._isActionDiagnostics(action)) {
                    action.postDiagnosticInformation(_this._telemetrySession, _this._telemetryManifest, manifestToBeUpdated);
                }
            });
        });
    };
    TelemetryEventProcessor._isActionDiagnostics = function (a) {
        return a.postDiagnosticInformation !== undefined;
    };
    return TelemetryEventProcessor;
}());
exports.TelemetryEventProcessor = TelemetryEventProcessor;
