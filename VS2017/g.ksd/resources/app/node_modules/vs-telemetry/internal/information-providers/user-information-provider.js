/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
"use strict";
var lazy_disposable_1 = require("lazy-disposable");
var guidHelper = require("../helpers/guid-helper");
var uuid = require("node-uuid");
/**
 * Provides platform-specific information about the user on the machine.
 */
var UserInformationProvider = (function () {
    function UserInformationProvider(storage, registryTools, internalSettings, errorCollector, retrier) {
        var _this = this;
        this._storage = storage;
        this._registryTools = registryTools;
        this._internalSettings = internalSettings;
        this._canCollectPrivateInformation = lazy_disposable_1.lazy(function () { return _this._isUserInternalForEligibleDomains(UserInformationProvider.canCollectPrivateInformationDomainList); });
        this._isUserMicrosoftInternal = lazy_disposable_1.lazy(function () { return _this._isUserInternalForEligibleDomains(UserInformationProvider.microsoftInternalDomainList); });
        this._userId = lazy_disposable_1.lazy(function () { return _this._calculateUserId(); });
        this._errorCollector = errorCollector;
        this._retrier = retrier;
    }
    /**
     * Gets the username of the user on the machine.
     *
     */
    UserInformationProvider.prototype.getUserName = function () {
        if (process.platform === "win32") {
            // get user name from system environment variable.
            // when upgrade to node.js v6.0 or above builds,
            // we can use the built-in method userInfo().username from OS module.
            // details: https://nodejs.org/api/os.html#os_os_userinfo_options
            if (process.env.username !== undefined) {
                return Promise.resolve(process.env.username);
            }
            else {
                return Promise.resolve(null);
            }
        }
        else {
            // If on Mac or Linux, user can specify a username override.
            return this._internalSettings.getUsernameOverride().then(function (usernameOverride) {
                if (usernameOverride && usernameOverride.length > 0) {
                    return usernameOverride;
                }
                else if (process.env.user !== undefined) {
                    return process.env.user;
                }
                else {
                    return null;
                }
            });
        }
    };
    /**
     * Gets the domain name of the user. This is the first part of a full dot-separated domain
     * name.
     */
    UserInformationProvider.prototype.getDomainName = function () {
        if (process.platform === "win32") {
            if (process.env.userdomain !== undefined) {
                return Promise.resolve(process.env.userdomain);
            }
            return this._internalSettings.getFullDomainName().then(function (fullDomainName) {
                if (!fullDomainName || fullDomainName.length === 0) {
                    return null;
                }
                var index = fullDomainName.indexOf(".");
                if (index !== -1) {
                    return fullDomainName.substr(0, index);
                }
                return fullDomainName;
            });
        }
        return Promise.resolve(null);
    };
    /**
     * Indicates if we are allowed to collect private information about this user
     * (such as machine name and user name)
     */
    UserInformationProvider.prototype.canCollectPrivateInformation = function () {
        return this._canCollectPrivateInformation();
    };
    /**
     * Indicates if the user is internal (working) at Microsoft.
     */
    UserInformationProvider.prototype.isUserMicrosoftInternal = function () {
        return this._isUserMicrosoftInternal();
    };
    /**
     * Provides the UserId in a platform-specific way.
     * @return Promise on completion returns the UserId
     */
    UserInformationProvider.prototype.getUserId = function () {
        return this._userId();
    };
    UserInformationProvider.prototype._calculateUserId = function () {
        var _this = this;
        if (process.platform === "win32") {
            return this._retrier.attemptTask(function () { return _this._registryTools.getStringFromHKCU(UserInformationProvider.userRegKey, UserInformationProvider.userRegName); }, function (errors) { return _this._errorCollector.collectErrors("UserId", "_calculateUserId", errors); }).then(function (userRegValue) {
                var normalizedGuid = guidHelper.stripBrackets(userRegValue);
                if (guidHelper.isGuid(normalizedGuid)) {
                    return normalizedGuid;
                }
                else {
                    throw "found a value in registry, but wasn't a guid";
                }
            }).catch(function (_) {
                return _this._generateUserIdAndSetRegistry();
            });
        }
        else {
            return this._getUserIdFromStorage();
        }
    };
    /**
     * Generates a new userId and set in the registry.
     */
    UserInformationProvider.prototype._generateUserIdAndSetRegistry = function () {
        var _this = this;
        var userId = this._generateUserId();
        return this._registryTools
            .setStringInHKCU(UserInformationProvider.userRegKey, UserInformationProvider.userRegName, guidHelper.addBrackets(userId))
            .then(function () { return userId; }, 
        // If we couldn't store it, use the empty GUID.
        function (error) {
            _this._errorCollector.collectError("UserId", "_generateUserIdAndSetRegistry", error);
            return guidHelper.emptyGuid;
        });
    };
    /**
     * Attemps to pull the userId from storage. If it doesn't exist, generates a new one and stores it.
     */
    UserInformationProvider.prototype._getUserIdFromStorage = function () {
        var _this = this;
        return this._storage
            .getItem(UserInformationProvider.userIdKey)
            .then(function (userId) {
            if (userId && typeof userId === "string" && guidHelper.isGuid(userId)) {
                return userId;
            }
            return _this._generateStoreAndReturnUserId();
        })
            .catch(function (error) {
            _this._errorCollector.collectError("UserId", "_getUserIdFromStorage", error);
            return _this._generateStoreAndReturnUserId();
        });
    };
    /**
     * Attemps to set a new userId in storage. If it fails, returns empty Guid to not throw off user counts.
     */
    UserInformationProvider.prototype._generateStoreAndReturnUserId = function () {
        var _this = this;
        var generatedUserId = this._generateUserId();
        return this._storage.setItem(UserInformationProvider.userIdKey, generatedUserId)
            .then(function (_) { return generatedUserId; })
            .catch(function (error) {
            _this._errorCollector.collectError("UserId", "_generateStoreAndReturnUserId", error);
            return guidHelper.emptyGuid;
        });
    };
    /**
     * Generates a new UserId.
     */
    UserInformationProvider.prototype._generateUserId = function () {
        return uuid.v4();
    };
    /**
     * Checks if user can be considered internal agains the specified domainList.
     * @return true if user can be considered internal
     */
    UserInformationProvider.prototype._isUserInternalForEligibleDomains = function (domainList) {
        var _this = this;
        return this._internalSettings.isForcedUserExternal().then(function (forcedUserExternal) {
            if (forcedUserExternal) {
                return false;
            }
            if (process.platform === "win32") {
                return _this._internalSettings.getFullDomainName().then(function (domainName) {
                    if (!domainName) {
                        return false;
                    }
                    return domainList[domainName.toLowerCase()] ? true : false;
                });
            }
            else {
                // If on Mac or Linux, user can coerce being internal by providing a username override.
                return _this._internalSettings.getUsernameOverride().then(function (usernameOverride) {
                    return usernameOverride && usernameOverride.length > 0;
                });
            }
        });
    };
    UserInformationProvider.userIdKey = "vstelemetry.userId";
    UserInformationProvider.userRegKey = "\\Software\\Microsoft\\SQMClient";
    UserInformationProvider.userRegName = "UserId";
    UserInformationProvider.canCollectPrivateInformationDomainList = {
        "redmond.corp.microsoft.com": true,
        "northamerica.corp.microsoft.com": true,
        "fareast.corp.microsoft.com": true,
        "ntdev.corp.microsoft.com": true,
        "wingroup.corp.microsoft.com": true,
        "southpacific.corp.microsoft.com": true,
        "wingroup.windeploy.ntdev.microsoft.com": true,
        "ddnet.microsoft.com": true,
    };
    UserInformationProvider.microsoftInternalDomainList = {
        "redmond.corp.microsoft.com": true,
        "northamerica.corp.microsoft.com": true,
        "fareast.corp.microsoft.com": true,
        "ntdev.corp.microsoft.com": true,
        "wingroup.corp.microsoft.com": true,
        "southpacific.corp.microsoft.com": true,
        "wingroup.windeploy.ntdev.microsoft.com": true,
        "ddnet.microsoft.com": true,
        "europe.corp.microsoft.com": true,
    };
    return UserInformationProvider;
}());
exports.UserInformationProvider = UserInformationProvider;
