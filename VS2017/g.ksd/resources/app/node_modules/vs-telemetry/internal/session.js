/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var uuid = require("node-uuid");
var vs_telemetry_api_1 = require("vs-telemetry-api");
var service_session_initializer_1 = require("./service-session-initializer");
var index_1 = require("../index");
var context_1 = require("./context");
var telemetry_scope_1 = require("./telemetry-scope");
var type_converters_1 = require("./helpers/type-converters");
var dateHelper = require("./helpers/date-helper");
var InternalEvent = (function (_super) {
    __extends(InternalEvent, _super);
    function InternalEvent() {
        _super.apply(this, arguments);
    }
    return InternalEvent;
}(vs_telemetry_api_1.Event));
exports.InternalEvent = InternalEvent;
function createSession(sessionInitializer, isSessionCloned) {
    if (isSessionCloned === void 0) { isSessionCloned = false; }
    return new ServiceSession(sessionInitializer, isSessionCloned);
}
exports.createSession = createSession;
var ServiceSession = (function () {
    /**
     * Create new session using settings from sessionInitializer object.
     */
    function ServiceSession(sessionInitializer, isSessionCloned) {
        var _this = this;
        if (isSessionCloned === void 0) { isSessionCloned = false; }
        this._isDisposed = false;
        this._isStarted = false;
        this._isInitialized = false;
        this._sessionCreatedTimeMs = Date.now();
        this._sessionContexts = {};
        this._sessionContextStack = [];
        // Represents a bunch of promises that can run in parallel before session is initialized.
        this._preInitializationPromises = [];
        this._sessionSettings = sessionInitializer.sessionSettings;
        this._startPromise = new Promise(function (resolve, reject) {
            _this._startResolve = resolve;
        });
        this._internalSettings = sessionInitializer.internalSettings;
        this._channelFactories = sessionInitializer.channelFactories;
        this._routerFactory = sessionInitializer.routerFactory;
        this._channelValidators = sessionInitializer.channelValidators;
        this._eventProcessorFactory = sessionInitializer.eventProcessorFactory;
        this._eventScheduler = sessionInitializer.eventScheduler;
        this._propertyProviders = sessionInitializer.propertyProviders;
        this._userInformationProvider = sessionInitializer.userInformationProvider;
        this._machineInformationProvider = sessionInitializer.machineInformationProvider;
        this._hostInformationProvider = sessionInitializer.hostInformationProvider;
        this._manifestManager = sessionInitializer.manifestManagerFactory(function (telemetryManifest) { return _this._onUpdateTelemetryManifest(telemetryManifest); }, this);
        this._persistentSharedProperties = sessionInitializer.persistentSharedProperties;
        sessionInitializer.errorCollector.setSession(this);
        this._isSessionCloned = isSessionCloned;
        this._optinStatusReader = sessionInitializer.optinStatusReader;
        this._setUserOptedInPromise = Promise.resolve(null);
        this._retrier = sessionInitializer.retrier;
        // acquire sessionId
        if (this._sessionSettings.Id === null) {
            this._sessionSettings.Id = uuid.v4();
        }
        if (this._sessionSettings.ProcessStartTime === null) {
            this._sessionSettings.ProcessStartTime = dateHelper.epochDateToTicks(this._sessionCreatedTimeMs);
        }
        else {
            this._sessionCreatedTimeMs = dateHelper.ticksToEpochDate(this._sessionSettings.ProcessStartTime);
        }
        this._defaultContext = new context_1.ServiceContext(ServiceSession._defaultContextName, this, null, isSessionCloned);
    }
    /**
     * Get session id.
     */
    ServiceSession.prototype.sessionId = function () {
        return Promise.resolve(this._sessionSettings.Id);
    };
    /**
     * Get UserId for the current instance
     */
    ServiceSession.prototype.userId = function () {
        return this._userInformationProvider.getUserId();
    };
    /**
     * Get ProcessStartTime for the current instance.
     */
    ServiceSession.prototype.processStartTime = function () {
        return Promise.resolve(this._sessionSettings.ProcessStartTime);
    };
    /**
     * Check whether user is Microsoft internal
     */
    ServiceSession.prototype.isMicrosoftInternal = function () {
        return this._userInformationProvider.isUserMicrosoftInternal();
    };
    /**
     * Check whether telemetry can collect private information without hashing it
     */
    ServiceSession.prototype.canCollectPrivateInformation = function () {
        return this._userInformationProvider.canCollectPrivateInformation();
    };
    /**
     * Return user alias in the case when we can collect PII.
     * In the other case return empty string ""
     */
    ServiceSession.prototype.userAlias = function () {
        var _this = this;
        return this
            ._userInformationProvider
            .canCollectPrivateInformation()
            .then(function (canCollectPii) { return canCollectPii ?
            _this._userInformationProvider.getUserName() :
            ""; });
    };
    /**
     * Get MachineId for the current instance
     */
    ServiceSession.prototype.machineId = function () {
        return this._machineInformationProvider.getMachineId();
    };
    /**
     * Get is user opted-in status.
     */
    ServiceSession.prototype.isOptedIn = function () {
        var _this = this;
        return this
            ._setUserOptedInPromise
            .then(function (_) { return _this._sessionSettings.IsOptedIn; });
    };
    ServiceSession.prototype.isEnabled = function () {
        return this
            ._internalSettings
            .isTelemetryDisabledCompletely()
            .then(function (isDisabled) { return !isDisabled; });
    };
    /**
     * Set is user opted-in status.
     */
    ServiceSession.prototype.setIsOptedIn = function (isUserOptedIn) {
        this._sessionSettings.IsOptedIn = isUserOptedIn;
        this._setOptedInProperty();
    };
    ServiceSession.prototype.useVsIsOptedIn = function (productVersion) {
        var _this = this;
        this._setUserOptedInPromise = this
            ._optinStatusReader
            .readIsOptedInStatus(productVersion)
            .then(function (optinStatus) { return _this.setIsOptedIn(optinStatus); })
            .catch(function (_) { return null; });
    };
    /**
     * Start session. Initialize transport channels and start posting pending events.
     */
    ServiceSession.prototype.start = function () {
        var _this = this;
        if (!this._isStarted) {
            this._runOnAvailability(function () {
                (_a = _this._preInitializationPromises).push.apply(_a, _this._propertyProviders.map(function (provider) {
                    return provider.addSharedProperties(_this._defaultContext);
                }));
                var channels = _this._channelFactories.map(function (factory) { return factory(_this); });
                var router = _this._routerFactory(channels);
                // kick-off validation for all channels
                channels.forEach(function (channel) {
                    return (_a = _this._preInitializationPromises).push.apply(_a, _this._channelValidators.map(function (validator) {
                        return validator.validate(channel);
                    }));
                    var _a;
                });
                _this._eventProcessor = _this._eventProcessorFactory(router, _this);
                // Avoid sending context posted properties if cloned session since
                // we can get them from original session.
                if (!_this._isSessionCloned) {
                    (_b = _this._preInitializationPromises).push.apply(_b, _this._propertyProviders.map(function (provider) {
                        return provider.postProperties(_this._defaultContext);
                    }));
                }
                _this._preInitializationPromises.push(_this._setUserOptedInPromise);
                _this._manifestManager.start();
                var _a, _b;
            });
            this._isStarted = true;
        }
    };
    /**
     * Post event to the existing session. Implementation of the ServiceSession interface
     */
    ServiceSession.prototype.postEvent = function (event) {
        if (!this._isDisposed) {
            var ev = void 0;
            if (typeof event === "string") {
                ev = new vs_telemetry_api_1.Event(event);
            }
            else {
                ev = event;
            }
            ServiceSession.validateEvent(ev);
            context_1.ServiceContext.validateEvent(ev);
            this.postValidatedEvent(ev);
        }
    };
    ServiceSession.prototype.postOperation = function (eventName, result, resultSummary, eventProperties, severity) {
        if (eventProperties === void 0) { eventProperties = {}; }
        if (severity === void 0) { severity = vs_telemetry_api_1.TelemetrySeverity.Normal; }
        return this._postEventAndGetCorrelation(new vs_telemetry_api_1.OperationEvent(eventName, result, resultSummary, eventProperties, severity));
    };
    ServiceSession.prototype.postUserTask = function (eventName, result, resultSummary, eventProperties, severity) {
        if (eventProperties === void 0) { eventProperties = {}; }
        if (severity === void 0) { severity = vs_telemetry_api_1.TelemetrySeverity.High; }
        return this._postEventAndGetCorrelation(new vs_telemetry_api_1.UserTaskEvent(eventName, result, resultSummary, eventProperties, severity));
    };
    ServiceSession.prototype.postAsset = function (eventName, assetId, assetEventVersion, eventProperties, severity) {
        if (eventProperties === void 0) { eventProperties = {}; }
        if (severity === void 0) { severity = vs_telemetry_api_1.TelemetrySeverity.Normal; }
        return this._postEventAndGetCorrelation(new vs_telemetry_api_1.AssetEvent(eventName, assetId, assetEventVersion, eventProperties, severity));
    };
    ServiceSession.prototype.postFault = function (eventName, description, error, eventProperties, severity) {
        if (eventProperties === void 0) { eventProperties = {}; }
        if (severity === void 0) { severity = vs_telemetry_api_1.TelemetrySeverity.High; }
        return this._postEventAndGetCorrelation(new vs_telemetry_api_1.FaultEvent(eventName, description, error, eventProperties, severity));
    };
    ServiceSession.prototype.startOperation = function (eventName, startEventPropertiesOrScopeSettings, severity, correlations) {
        var scopeSettings = this._getScopeSettings(startEventPropertiesOrScopeSettings, vs_telemetry_api_1.TelemetrySeverity.Normal, /*default severity is Normal for operation*/ severity, correlations);
        return new telemetry_scope_1.InternalTelemetryScope(telemetry_scope_1.ScopeOperationEvent, this, eventName, scopeSettings);
    };
    ServiceSession.prototype.startUserTask = function (eventName, startEventPropertiesOrScopeSettings, severity, correlations) {
        var scopeSettings = this._getScopeSettings(startEventPropertiesOrScopeSettings, vs_telemetry_api_1.TelemetrySeverity.High, /*default severity is High for user task*/ severity, correlations);
        return new telemetry_scope_1.InternalTelemetryScope(telemetry_scope_1.ScopeUserTaskEvent, this, eventName, scopeSettings);
    };
    /**
     * Posts validated event. Only for internal usage. Does not check if session already disposed.
     */
    ServiceSession.prototype.postValidatedEvent = function (event) {
        var _this = this;
        var ev = vs_telemetry_api_1.Event.clone(event);
        // for consistency make the event name in the lowercase
        ev.name = ev.name.toLowerCase();
        this._addContextProperties(ev);
        ev.postTimeStamp = Date.now();
        // set TimeSinceSessionStart as early as possible
        ev.properties["Reserved.TimeSinceSessionStart"] = ev.postTimeStamp - this._sessionCreatedTimeMs;
        var firstFlush = !this._isInitialized;
        // chain events in order to create queue, before client calls start() method
        this._startPromise = this._startPromise.then(function (_) { return _this._runOnAvailability(function () {
            return _this._postEventToChannels(ev, firstFlush);
        }); });
    };
    /**
     * Adds a session-wide property that is posted once.
     */
    ServiceSession.prototype.postProperty = function (propertyName, propertyValue) {
        this._defaultContext.postProperty(propertyName, propertyValue);
    };
    /**
     * Gets a shared property. If property doesn't exist, returns null.
     */
    ServiceSession.prototype.getSharedProperty = function (propertyName) {
        return this._defaultContext.getSharedProperty(propertyName);
    };
    /**
     * Sets a shared property that is added to each event in the session.
     * This sets a shared property in the default context.
     */
    ServiceSession.prototype.setSharedProperty = function (propertyName, propertyValue) {
        this._defaultContext.setSharedProperty(propertyName, propertyValue);
    };
    /**
     * Removes a shared property.
     * This removes the shared property from the default context.
     */
    ServiceSession.prototype.removeSharedProperty = function (propertyName) {
        this._defaultContext.removeSharedProperty(propertyName);
    };
    ServiceSession.prototype.getPersistedSharedProperty = function (propertyName) {
        return this._persistentSharedProperties.getItem(propertyName).catch(function (_) { return null; });
    };
    ServiceSession.prototype.setPersistedSharedProperty = function (propertyName, propertyValue) {
        var _this = this;
        var setAndInstrument = function (oldPropertyValue, isSuccess, error) {
            _this._defaultContext.setSharedProperty(propertyName, propertyValue);
            // Only instrument if we actually set something
            if (oldPropertyValue == null || oldPropertyValue !== propertyValue) {
                _this._instrumentPersistedSharedProperty("Set", propertyName, propertyValue, oldPropertyValue, isSuccess, error);
            }
        };
        return this.getPersistedSharedProperty(propertyName).then(function (previousValue) {
            return _this._persistentSharedProperties.setItem(propertyName, propertyValue).then(function (_) { return setAndInstrument(previousValue, true); }, function (error) {
                setAndInstrument(previousValue, false, error);
            });
        });
    };
    ServiceSession.prototype.removePersistedSharedProperty = function (propertyName) {
        var _this = this;
        var removeAndInstrument = function (propertyValue, isSuccess, error) {
            _this._defaultContext.removeSharedProperty(propertyName);
            // Only instrument if we actually removed something
            if (propertyValue != null) {
                _this._instrumentPersistedSharedProperty("Remove", propertyName, propertyValue, null, isSuccess, error);
            }
        };
        return this.getPersistedSharedProperty(propertyName).then(function (previousValue) {
            return _this._persistentSharedProperties.removeItem(propertyName).then(function (_) { return removeAndInstrument(previousValue, true); }, function (error) {
                removeAndInstrument(previousValue, false, error);
            });
        });
    };
    ServiceSession.prototype.setHostInformation = function (hostInformation) {
        if (this._isStarted) {
            throw new index_1.InvalidOperationException("cannot set host information after starting");
        }
        this._hostInformationProvider.overrideHostInformation(hostInformation);
    };
    /**
     * Serialize session settings to a string.
     */
    ServiceSession.prototype.serializeSettings = function () {
        var _this = this;
        return this._setUserOptedInPromise.then(function (_) {
            return JSON.stringify(_this._sessionSettings, service_session_initializer_1.ServiceSessionSettings.propertiesToSerialize());
        });
    };
    /**
     * Creates a new TelemetryContext with the specified name.
     */
    ServiceSession.prototype.createContext = function (contextName) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            try {
                resolve(new context_1.ServiceContext(contextName, _this, null));
            }
            catch (error) {
                reject(error);
            }
        });
    };
    /**
     * Registers a context with the session.
     */
    ServiceSession.prototype.addContext = function (context) {
        if (this._isDisposed) {
            return;
        }
        var contextName = context.name();
        if (this._sessionContexts.hasOwnProperty(contextName)) {
            throw new index_1.ArgumentException("a context with name '" + contextName + "' already exists.");
        }
        this._sessionContexts[contextName] = context;
        this._sessionContextStack.push(context);
    };
    /**
     * Removes a context from the session.
     */
    ServiceSession.prototype.removeContext = function (context) {
        delete this._sessionContexts[context.name()];
        var index = this._sessionContextStack.indexOf(context);
        this._sessionContextStack.splice(index, 1);
    };
    /**
     * If session is cloned
     */
    ServiceSession.prototype.isSessionCloned = function () {
        return this._isSessionCloned;
    };
    /**
     * Shutdown session. Return promise which is resolved when session successfully disposed.
     * We queue dispose call at the end of the event chains.
     */
    ServiceSession.prototype.dispose = function () {
        var _this = this;
        if (!this._isDisposed) {
            /*
             * We need to start session, if it was not started
             * in order to flush all events.
             */
            this.start();
            this._isDisposed = true;
            this._disposePromise = new Promise(function (resolve, reject) {
                _this._runOnAvailability(function () {
                    /*
                     * Wait for all operations are completed:
                     * - all events are sent to scheduler;
                     * - all events in the scheduler are executed;
                     * - eventProcessor completed its work.
                     */
                    // We want to dispose remaining contexts in reverse order of creation,
                    // not simultaneously.
                    // Always want default context to be disposed last.
                    var disposeStart;
                    var contextDispose = new Promise(function (contextResolve, contextReject) {
                        disposeStart = contextResolve;
                    });
                    _this._sessionContextStack.reverse().map(function (context) { return function () { return context.dispose(); }; }).forEach(function (dispose) {
                        contextDispose = contextDispose.then(function (_) { return dispose(); });
                    });
                    // We are disposing so cancel any retries in progress and resolve their promises immediately.
                    _this._retrier.cancelAll()
                        .then(function (_) { return _this._startPromise; })
                        .then(function (_) { return _this._eventProcessor.postDiagnosticInformationIfNeeded(); })
                        .then(function (_) {
                        disposeStart();
                        return contextDispose;
                    })
                        .then(function (_) { return _this._startPromise; })
                        .then(function (_) { return _this._manifestManager.dispose(); })
                        .then(function (_) { return _this._eventScheduler.dispose(); })
                        .then(function (_) { return _this._eventProcessor.dispose(); })
                        .then(function (_) { return resolve(); });
                }, function () {
                    /**
                     * in case when service is not available we need to resolve promise
                     * in order to not force customers wait forever on dispose
                     */
                    resolve();
                });
            });
        }
        return this._disposePromise;
    };
    /**
     * Validates telemetry event.
     */
    ServiceSession.validateEvent = function (event) {
        for (var propName in event.properties) {
            if (event.properties.hasOwnProperty(propName)) {
                if (vs_telemetry_api_1.Event.isPropertyNameReserved(propName)) {
                    throw new index_1.ArgumentException("property '" + propName + "' has reserved prefix 'Reserved'");
                }
            }
        }
    };
    ServiceSession.prototype._postEventAndGetCorrelation = function (ev) {
        this.postEvent(ev);
        return Promise.resolve(ev.correlation);
    };
    /**
     * Adds context properties to the event.
     */
    ServiceSession.prototype._addContextProperties = function (event, overwriteExisting) {
        var _this = this;
        if (overwriteExisting === void 0) { overwriteExisting = true; }
        Object.keys(this._sessionContexts).map(function (key) {
            return _this._sessionContexts[key].processEvent(event, overwriteExisting);
        });
    };
    /**
     * Run action on telemetry service availability.
     * @param enabled run this action when telemetry service is available
     * @param disabled run this action when telemetry service is disabled
     */
    ServiceSession.prototype._runOnAvailability = function (enabled, disabled) {
        return this.isEnabled().then(function (isEnabled) {
            if (isEnabled) {
                return enabled();
            }
            else if (disabled !== undefined) {
                return disabled();
            }
        });
    };
    /**
     * This method is called when Session object is ready to send events to the channels.
     */
    ServiceSession.prototype._postEventToChannels = function (event, isFirstFlush) {
        var _this = this;
        // add required properties
        if (isFirstFlush) {
            // Re-add the default context properties because they may have changed
            // since we first added them. Do not overwrite the original values.
            this._defaultContext.processEvent(event, false);
        }
        event.properties["Reserved.EventId"] = uuid.v4();
        event.properties["Reserved.SessionId"] = this._sessionSettings.Id;
        this._eventScheduler.schedule(function () { return _this._eventProcessor.processEvent(event); });
        return Promise.resolve(null);
    };
    /**
     * This method is called whenever a new telemetry manifest is downloaded.
     */
    ServiceSession.prototype._onUpdateTelemetryManifest = function (telemetryManifest) {
        var _this = this;
        if (telemetryManifest != null) {
            this._eventProcessor.setManifest(telemetryManifest);
        }
        if (!this._isInitialized) {
            Promise.all(this._preInitializationPromises).then(function (_) {
                if (!_this._isSessionCloned) {
                    _this.postValidatedEvent(new vs_telemetry_api_1.Event("vs/telemetryapi/session/initialized"));
                }
                _this._setOptedInProperty();
                // flush event queue
                _this._startResolve();
                _this._isInitialized = true;
            });
        }
    };
    /**
     * Sets the OptedIn shared property to the current value.
     */
    ServiceSession.prototype._setOptedInProperty = function () {
        this.setSharedProperty("VS.Core.User.IsOptedIn", type_converters_1.TypeConverters.boolToString(this._sessionSettings.IsOptedIn));
    };
    /**
     * Instruments persisted shared property
     */
    ServiceSession.prototype._instrumentPersistedSharedProperty = function (eventName, propertyName, propertyValue, oldPropertyValue, isSuccess, error) {
        var eventNamePrefix = "VS/TelemetryApi/PersistedSharedProperty/";
        var propertyPrefix = "VS.TelemetryApi.PersistedSharedProperty.";
        var diagnosticEvent = new vs_telemetry_api_1.Event(eventNamePrefix + eventName);
        diagnosticEvent.properties[propertyPrefix + "Name"] = propertyName;
        diagnosticEvent.properties[propertyPrefix + "Value"] = propertyValue;
        if (oldPropertyValue != null) {
            diagnosticEvent.properties[propertyPrefix + "OldValue"] = oldPropertyValue;
        }
        diagnosticEvent.properties[propertyPrefix + "IsSuccess"] =
            type_converters_1.TypeConverters.boolToString(isSuccess);
        if (error != null) {
            diagnosticEvent.properties[propertyPrefix + "ErrorMessage"] =
                new vs_telemetry_api_1.PiiProperty(error.toString(), vs_telemetry_api_1.PiiAction.Sanitized);
            if (error.innerError != null) {
                diagnosticEvent.properties[propertyPrefix + "InnerErrorMessage"] =
                    new vs_telemetry_api_1.PiiProperty(error.innerError.toString(), vs_telemetry_api_1.PiiAction.Sanitized);
            }
        }
        this.postEvent(diagnosticEvent);
    };
    ServiceSession.prototype._getScopeSettings = function (startEventPropertiesOrScopeSettings, defaultSeverity, severity, correlations) {
        var scopeSettings;
        if (startEventPropertiesOrScopeSettings != null
            && startEventPropertiesOrScopeSettings instanceof vs_telemetry_api_1.TelemetryScopeSettings) {
            scopeSettings = startEventPropertiesOrScopeSettings;
        }
        else {
            scopeSettings = new vs_telemetry_api_1.TelemetryScopeSettings();
            scopeSettings.correlations = correlations;
            scopeSettings.startEventProperties = startEventPropertiesOrScopeSettings;
            if (severity != null) {
                scopeSettings.severity = severity;
            }
            else {
                // we set high for user task by default.
                scopeSettings.severity = defaultSeverity;
            }
        }
        return scopeSettings;
    };
    ServiceSession._defaultContextName = "Default";
    return ServiceSession;
}());
exports.ServiceSession = ServiceSession;
