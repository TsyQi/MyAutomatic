/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
"use strict";
var index_1 = require("../index");
var TaskState;
(function (TaskState) {
    TaskState[TaskState["InProgress"] = 0] = "InProgress";
    TaskState[TaskState["Scheduled"] = 1] = "Scheduled";
    TaskState[TaskState["Failed"] = 2] = "Failed";
    TaskState[TaskState["Succeeded"] = 3] = "Succeeded";
})(TaskState || (TaskState = {}));
var Task = (function () {
    function Task() {
        this.errors = [];
        this.isCancelled = false;
    }
    return Task;
}());
var ProgressiveTaskRetrier = (function () {
    function ProgressiveTaskRetrier(timedSchedulerFactory, initialTimeout, maxTimeout) {
        if (initialTimeout === void 0) { initialTimeout = 200; }
        if (maxTimeout === void 0) { maxTimeout = 1600; }
        this._tasks = [];
        this._isCancelled = false;
        this._timedSchedulerFactory = timedSchedulerFactory;
        this._initialTimeout = initialTimeout;
        this._maxTimeout = maxTimeout;
    }
    ProgressiveTaskRetrier.prototype.attemptTask = function (work, errorsCallback) {
        if (this._isCancelled) {
            return Promise.reject(new index_1.InvalidOperationException("cannot attemptTask once cancelled"));
        }
        return this._attemptTaskAndCollectErrors(work).then(function (resultWithErrors) {
            return Promise.resolve(errorsCallback(resultWithErrors.errors)).then(function (_) { return resultWithErrors.result; });
        }, function (errors) {
            return Promise.resolve(errorsCallback(errors)).then(function (_) { throw errors[errors.length - 1]; });
        });
    };
    ProgressiveTaskRetrier.prototype.cancelAll = function () {
        if (!this._isCancelled) {
            var cancelTasks_1 = [];
            this._tasks.forEach(function (task) {
                task.isCancelled = true;
                if (task.state === TaskState.InProgress) {
                    // Task is in progress so wait on it.
                    // The handler above in attemptTask will deal with the outcome.
                    cancelTasks_1.push(task.lastTry.then(function (_) { return null; }).catch(function (_) { return null; }));
                }
                else if (task.state === TaskState.Scheduled) {
                    cancelTasks_1.push(task.timer.dispose().then(function (_) {
                        task.reject(task.errors);
                    }));
                }
            });
            this._isCancelled = true;
            return Promise.all(cancelTasks_1).then(function (_) { return null; });
        }
        return Promise.resolve(null);
    };
    ProgressiveTaskRetrier.prototype._attemptTaskAndCollectErrors = function (work) {
        var _this = this;
        var task = new Task();
        task.nextTimeout = this._initialTimeout;
        var promise = new Promise(function (resolve, reject) {
            task.reject = reject;
            var scope = function () {
                task.state = TaskState.InProgress;
                var workPromise = work();
                task.lastTry = workPromise;
                workPromise.then(function (result) {
                    task.state = TaskState.Succeeded;
                    resolve({ result: result, errors: task.errors });
                }, function (error) {
                    task.errors.push(error);
                    if (task.nextTimeout > _this._maxTimeout || task.isCancelled) {
                        task.state = TaskState.Failed;
                        reject(task.errors);
                    }
                    else {
                        var timer = _this._timedSchedulerFactory(task.nextTimeout);
                        task.timer = timer;
                        task.nextTimeout *= 2;
                        task.state = TaskState.Scheduled;
                        timer.schedule(scope);
                    }
                });
            };
            scope();
        });
        this._tasks.push(task);
        return promise;
    };
    return ProgressiveTaskRetrier;
}());
exports.ProgressiveTaskRetrier = ProgressiveTaskRetrier;
