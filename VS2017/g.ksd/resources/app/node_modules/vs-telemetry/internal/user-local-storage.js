/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
"use strict";
var path = require("path");
var os = require("os");
var fsp = require("node-fs-promise");
var stringjs = require("string");
var index_1 = require("../index");
var serializationHelper = require("./helpers/serialization-helper");
var atomic_file_writer_1 = require("./atomic-file-writer");
var userStorage;
var UserLocalStorage = (function () {
    function UserLocalStorage(location, fileExtension, fileWriter) {
        this._location = location;
        if (fileExtension != null) {
            if (fileExtension.length === 0) {
                throw new index_1.ArgumentException("cannot have empty file extension");
            }
            if (fileExtension[0] !== ".") {
                fileExtension = "." + fileExtension;
            }
        }
        this._fileExtension = fileExtension;
        this._initPromise = this._init();
        this._fileWriter = fileWriter;
    }
    /**
     * Gets all items in the specified directory with the fileExtension.
     * @return Promise on completion with the key-value pairs, fileExtension removed from keys
     */
    UserLocalStorage.prototype.getAllItems = function () {
        var _this = this;
        if (this._fileExtension == null) {
            return Promise.reject(new index_1.ArgumentException("cannot use getAllItems without fileExtension"));
        }
        var result = {};
        return fsp.readdir(this._location).then(function (files) {
            var promises = [];
            files.forEach(function (file) {
                if (stringjs(file).endsWith(_this._fileExtension)) {
                    var filePath_1 = path.join(_this._location, file);
                    var fileNameNoExtension_1 = file.substring(0, file.lastIndexOf("."));
                    promises.push(fsp.lstat(filePath_1).then(function (stats) {
                        if (stats.isFile()) {
                            return fsp.readFile(filePath_1, "utf8").then(function (fileContents) {
                                result[fileNameNoExtension_1] =
                                    serializationHelper.interpretSerializedValue(fileContents.trim());
                            });
                        }
                    }).catch(function (_) { return null; }));
                }
            });
            return Promise.all(promises).then(function (_) { return result; });
        }).catch(function (err) {
            result = {};
            return result;
        });
    };
    /**
     * Get the specified item from storage.
     * @param key key of item to retrieve
     * @return Promise on completion with the stored string
     */
    UserLocalStorage.prototype.getItem = function (key) {
        var _this = this;
        return this._initPromise.then(function () {
            if (!_this._isValidKey(key)) {
                throw new index_1.ArgumentException("key cannot be null or empty");
            }
            var filePath = path.join(_this._location, _this._keyToFileName(key));
            return fsp.lstat(filePath).then(function (stats) {
                if (!stats.isFile()) {
                    throw new index_1.StorageException("cannot get item with key: " + key);
                }
                return fsp.readFile(filePath, "utf8")
                    .then(function (fileContents) { return serializationHelper.interpretSerializedValue(fileContents.trim()); }, function (error) {
                    throw new index_1.StorageException("cannot get item with key: " + key, error);
                });
            }, 
            // File does not exist, so return null for key.
            function () { return null; });
        });
    };
    /**
     * Sets the specified item in storage.
     * Warning: this is not an atomic operation and may corrupt files if this is called with the same key
     * with different data at about the same time..
     * @param key key of item to store
     * @param value string to store
     * @return Promise on completion
     */
    UserLocalStorage.prototype.setItem = function (key, value) {
        var _this = this;
        return this._initPromise.then(function (_) {
            if (!_this._isValidKey(key)) {
                throw new index_1.ArgumentException("key cannot be null or empty");
            }
            return _this._fileWriter.writeFile(path.join(_this._location, _this._keyToFileName(key)), serializationHelper.prepareValue(value)).catch(function (error) { throw new index_1.StorageException("cannot set item with key: " + key, error); });
        });
    };
    /**
     * Removes the specified item from storage.
     * @param key key of item to removeItem
     * @return Promise on completion
     */
    UserLocalStorage.prototype.removeItem = function (key) {
        if (!this._isValidKey(key)) {
            return Promise.reject(new index_1.ArgumentException("key cannot be null or empty"));
        }
        return fsp.unlink(path.join(this._location, this._keyToFileName(key)))
            .catch(function (error) { throw new index_1.StorageException("cannot remove item with key: " + key, error); });
    };
    UserLocalStorage.prototype._isValidKey = function (key) {
        if (!key || key === "") {
            return false;
        }
        return true;
    };
    UserLocalStorage.prototype._init = function () {
        return this._ensureDirectoryCreated();
    };
    UserLocalStorage.prototype._ensureDirectoryCreated = function () {
        var _this = this;
        return fsp.lstat(this._location).then(function (stats) {
            if (stats.isFile()) {
                throw new index_1.StorageException("Error initializing storage");
            }
        }, function (_) { return fsp.mkdir(_this._location)
            .catch(function (error) { throw new index_1.StorageException("Error making storage directory", error); }); });
    };
    UserLocalStorage.prototype._keyToFileName = function (key) {
        if (this._fileExtension != null) {
            key += this._fileExtension;
        }
        return encodeURIComponent(key);
    };
    return UserLocalStorage;
}());
exports.UserLocalStorage = UserLocalStorage;
function getDefaultUserStorage() {
    if (userStorage === undefined) {
        // Create user storage without subdirectory
        userStorage = createUserStorage("", null);
    }
    return userStorage;
}
exports.getDefaultUserStorage = getDefaultUserStorage;
function createUserStorage(directory, fileExtension) {
    return new UserLocalStorage(path.join(calculateAppPath(), directory), fileExtension, new atomic_file_writer_1.AtomicFileWriter());
}
exports.createUserStorage = createUserStorage;
function calculateAppPath() {
    return path.join(calculateUserPath(), "vstelemetry");
}
/**
 * This userPath is the same used by Atom/electron browser.
 */
/* istanbul ignore next: ignore so far */
function calculateUserPath() {
    if (process.platform === "win32") {
        if (process.env.appdata !== undefined) {
            return process.env.appdata;
        }
    }
    else if (process.platform === "darwin") {
        return path.join(os.homedir(), "Library/Application Support");
    }
    else if (process.platform === "linux") {
        return path.join(os.homedir(), ".config");
    }
    return os.homedir();
}
